import os
import sys
import signal
import threading
import asyncio
import time
import socket
import subprocess
import json
import logging
from pathlib import Path
from mcp.server.fastmcp import FastMCP
from typing import List, Dict, Optional, Any
from serpapi import GoogleSearch
from rich.logging import RichHandler

# Message templates
SERVER_MESSAGES = {
    'server_start': 'google_hotel MCP server starting on port {port}',
    'server_started': 'google_hotel MCP server started successfully on port {port}',
    'server_stopped': 'google_hotel MCP server stopped',
    'server_start_fail': 'Failed to start google_hotel MCP server',
    'server_already_running': 'Server is already running',
    'server_not_running': 'Server is not running',
    'server_error': 'Server error: {error}',
    'start_error': 'Error starting server: {error}',
    'stop_error': 'Error stopping server: {error}',
    'stop_success': 'Server stopped successfully',
    'stop_fail': 'Server failed to stop',
    'status_running': 'google_hotel MCP server is running',
    'status_stopped': 'google_hotel MCP server is not running',
    'ping_success': 'Server is responding',
    'ping_fail': 'Server is not responding',
    'interrupt': 'Operation cancelled by user',
    'error': 'Error: {error}',
    'version': 'google_hotel MCP Server v{version}',
}

def format_message(key: str, **kwargs) -> str:
    """Format a server message with given parameters."""
    template = SERVER_MESSAGES.get(key, '')
    return template.format(**kwargs) if template else ''

# Load API Key
SERP_API_KEY = os.getenv("SERP_API_KEY")

# Configure logging for hotel search
def configure_logging(json_mode=False):
    """Configure logging based on output mode"""
    if json_mode:
        # In JSON mode, only log warnings and errors, redirect to stderr
        import sys
        handler = RichHandler(rich_tracebacks=True)
        handler.stream = sys.stderr
        logging.basicConfig(
            level=logging.WARNING,
            format="| %(levelname)-8s | %(name)s | %(message)s",
            datefmt="[%Y-%m-%d %H:%M:%S]",
            handlers=[handler],
            force=True
        )
    else:
        # In normal mode, use debug logging to stdout
        logging.basicConfig(
            level=logging.DEBUG,
            format="| %(levelname)-8s | %(name)s | %(message)s",
            datefmt="[%Y-%m-%d %H:%M:%S]",
            handlers=[RichHandler(rich_tracebacks=True)],
            force=True  # This overrides uvicorn & third-party loggers
        )

# Initialize with default logging (will be reconfigured based on args)
configure_logging()

logger = logging.getLogger("hotel_search")
logging.getLogger("uvicorn.access").setLevel(logging.INFO)
logging.getLogger("uvicorn.error").setLevel(logging.INFO)
logging.getLogger("httpx").setLevel(logging.WARNING)

# Initialize FastMCP server
# Generated by McpServerGen.py on 2025-07-29 14:43:09
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
google_hotel_PORT = int(os.getenv('MCP_GOOGLE_HOTEL_PORT', 7903))
google_hotel_PROTOCOL = os.getenv('MCP_GOOGLE_HOTEL_PROTOCOL', 'sse')
mcp = None  # Will be initialized after command line parsing

# Global variables for server management
_server_thread = None
_server_loop = None
_server_running = False
_server_start_time = None

#### Utility Functions ####

async def run_search(params: Dict[str, Any]):
    """
    Run SerpAPI search asynchronously.

    Args:
        params: Parameters for the SerpAPI search

    Returns:
        Search results from SerpAPI
    """
    try:
        logger.debug(
            f"Sending SerpAPI request with params: {json.dumps(params, indent=2)}"
        )
        result = await asyncio.to_thread(lambda: GoogleSearch(params).get_dict())
        logger.debug(f"SerpAPI response received, keys: {list(result.keys())}")
        return result
    except Exception as e:
        logger.exception(f"SerpAPI search error: {str(e)}")
        return {"error": str(e)}


def prepare_hotels_search_params(
    city: str,
    check_in_date: str,
    check_out_date: str,
    district: Optional[str] = "",
    adults: Optional[int] = 1,
    children: Optional[int] = 0,
    hotel_class: Optional[int] = 4,
) -> Dict[str, Any]:
    """
    Prepare parameters for a hotel search.

    Args:
        city: specify city name
        check_in_date: Check in date (YYYY-MM-DD)
        check_out_date: Check out date (YYYY-MM-DD)
        district:  the district where the hotel locates (default: "")
        adults: Number of adult passengers (default: 1)
        children: Number of children passengers (default: 0)
        hotel_class: defines to include only certain hotel class in the results (default: 4)

    Returns:
        Dictionary of parameters for SerpAPI
    """
    q = f"{city} hotel, {district} district" if district != "" else f"{city} hotel"
    params = {
        "api_key": SERP_API_KEY,
        "engine": "google_hotels",
        "hl": "en",
        "gl": "us",
        "q": q,
        "check_in_date": check_in_date,
        "check_out_date": check_out_date,
        "adults": adults,
        "children": children,
        "hotel_class": hotel_class,
        "currency": "USD",
    }
    logger.info(f"prepare_hotel_search_params: {params}")

    return params


def prepare_hotel_property_search_params(
    hotel_name: str,
    check_in_date: str,
    check_out_date: str,
    adults: Optional[int] = 1,
    children: Optional[int] = 0,
    hotel_class: Optional[int] = 4,
) -> Dict[str, Any]:
    """
    Prepare parameters for search property of a specific hotel.

    Args:
        hotel_name: the hotel name
        check_in_date: Check in date (YYYY-MM-DD)
        check_out_date: Check out date (YYYY-MM-DD)
        adults: Number of adult passengers (default: 1)
        children: Number of children passengers (default: 0)
        hotel_class: defines to include only certain hotel class in the results (default: 4)

    Returns:
        Dictionary of parameters for SerpAPI
    """
    params = {
        "api_key": SERP_API_KEY,
        "engine": "google_hotels",
        "hl": "en",
        "gl": "us",
        "q": hotel_name,
        "check_in_date": check_in_date,
        "check_out_date": check_out_date,
        "adults": adults,
        "children": children,
        "hotel_class": hotel_class,
        "currency": "USD",
    }
    logger.info(f"prepare_hotel_search_params: {params}")

    return params

#### Server Tools ####

async def search_hotel_tool(
    city: str,
    check_in_date: str,
    check_out_date: str,
    district: Optional[str] = "",
    adults: Optional[int] = 1,
    children: Optional[int] = 0,
    hotel_class: Optional[int] = 4,
):
    """
    Search for hotel using SerpAPI Google Hotel.

    This MCP tool allows AI models to search for hotel information by specifying
    departure and arrival airports and travel dates.

    Args:
        city: specify city name
        check_in_date: Check in date (YYYY-MM-DD)
        check_out_date: Check out date (YYYY-MM-DD)
        district:  the district where the hotel locates (default: "")
        adults: Number of adult passengers (default: 1)
        children: Number of children passengers (default: 0)
        hotel_class: defines to include only certain hotel class in the results (default: 4)

    Returns:
        A list of available hotel with details
    """
    logger.debug(
        f"Function called with: city={city}, check_in_date={check_in_date}, check_out_date={check_out_date}, district={district}, adults={adults}, children={children}, hotel_class={hotel_class}"
    )

    # Prepare search parameters
    params = prepare_hotels_search_params(
        city, check_in_date, check_out_date, district, adults, children, hotel_class
    )

    # Execute search
    logger.debug(f"Executing SerpAPI search for hotels in {city}...")

    search_results = await run_search(params)

    # Check for errors
    if "error" in search_results:
        logger.error(f"Hotel search error: {search_results['error']}")
        return {"error": search_results["error"]}

    # Process hotel results
    best_hotels = search_results.get("properties", [])
    logger.debug(f"Search complete. Found {len(best_hotels)} best hotels")

    if not best_hotels:
        logger.warning("No hotels found in search results")
        return []

    # Format hotel data
    formatted_hotels = []
    num_valid = 0
    for i, hotel in enumerate(best_hotels):
        if num_valid > 2:
            break
        logger.debug(f"Processing hotel {i+1} of {len(best_hotels)}")
        if not hotel.get("name"):
            logger.debug(f"Skipping hotel {i+1} as it has no hotel name")
            continue

        hotel_name = str(hotel.get("name"))
        # search address based on hotel_name
        property_params = prepare_hotel_property_search_params(
            hotel_name, check_in_date, check_out_date, adults, children, hotel_class
        )

        # Execute search
        logger.debug(f"Executing SerpAPI search for hotel {hotel_name}...")
        property_results = await run_search(property_params)
        # Check for errors
        if "error" in property_results:
            logger.error(
                f"Search hotel {hotel_name} got error: {property_results['error']}"
            )
            continue

        if "address" not in property_results:
            logger.debug(f"Skip hotel {hotel_name} since it has no address")
            continue

        rate_per_night = property_results.get("rate_per_night", {})
        total_rate = hotel.get("total_rate", {})

        link = str(property_results.get("link", "N/A"))
        print(f"@@@@link: {link}")

        # Add formatted hotels to results
        formatted_hotels.append(
            {
                "name": hotel_name,
                "address": str(property_results.get("address", "N/A")),
                "hotel_class": str(hotel.get("hotel_class", "N/A")),
                "rate_per_night": str(rate_per_night.get("lowest", "N/A")),
                "overall_rating": str(hotel.get("overall_rating", "N/A")),
                "link": str(property_results.get("link", "N/A")),
                # "check_in_time": str(hotel.get("check_in_time", "N/A")),
                # "check_out_time": str(hotel.get("check_out_time", "N/A"))
            }
        )
        num_valid += 1

    logger.info(f"Returning {len(formatted_hotels)} formatted hotels")
    return formatted_hotels


#### Tool Registration ####

# List of all tool functions to register
TOOL_FUNCTIONS = [
    search_hotel_tool,
    # Add additional tool functions here
]

def register_tools(verbose=True):
    """Register all tools with the MCP server."""
    global mcp
    if mcp is None:
        raise RuntimeError("MCP instance must be initialized before registering tools")
    
    for tool_func in TOOL_FUNCTIONS:
        mcp.tool()(tool_func)
        if verbose:
            print(f"Registered tool: {tool_func.__name__}")

#### Server management functions ####

def _run_server_in_thread(port, protocol):
    """Run the MCP server in a separate thread."""
    global _server_loop, _server_running
    
    _server_loop = asyncio.new_event_loop()
    asyncio.set_event_loop(_server_loop)
    
    try:
        _server_running = True
        print(format_message('server_start', port=port))
        mcp.run(transport="streamable-http" if protocol == "http" else protocol)
    except Exception as e:
        print(format_message('server_error', error=str(e)))
    finally:
        _server_running = False

def start_server(port=None, protocol=None):
    """Start the MCP server in a separate thread."""
    global _server_thread, _server_running, _server_start_time, mcp
    
    # Use provided parameters or fall back to global defaults
    if port is None:
        port = google_hotel_PORT
    if protocol is None:
        protocol = google_hotel_PROTOCOL
    
    if port != google_hotel_PORT:
        # Create fresh FastMCP instance with current port and protocol
        mcp = FastMCP("google_hotel", port=port)
        # Register all tools with the new instance
        register_tools()
        
    try:
        # Check if server is already running
        if _server_running:
            print(format_message('server_already_running'))
            return False

        _server_thread = threading.Thread(target=_run_server_in_thread, args=(port, protocol), daemon=True)
        _server_thread.start()
        
        # Start shutdown listener in a separate daemon thread
        threading.Thread(target=shutdown_listener, args=(port,), daemon=True).start()
        
        _server_start_time = time.time()
        
        time.sleep(2)  # Wait for server to start
        if _server_running:
            print(format_message('server_started', port=port))
            return True
        else:
            print(format_message('server_start_fail'))
            return False
    except Exception as e:
        print(format_message('start_error', error=str(e)))
        return False

def stop_server(json_mode=False, port=None):
    """Stop the MCP server using multiple reliable methods."""
    global _server_thread, _server_loop, _server_running

    # Use provided port or fall back to global default
    if port is None:
        port = google_hotel_PORT
    
    # First try to stop server started by this process
    if _server_running:
        try:
            _server_running = False
            
            # More aggressive shutdown
            if _server_loop and _server_loop.is_running():
                # Stop all running tasks in the loop
                for task in asyncio.all_tasks(_server_loop):
                    task.cancel()
                _server_loop.call_soon_threadsafe(_server_loop.stop)
            
            if _server_thread and _server_thread.is_alive():
                _server_thread.join(timeout=10)  # Increased timeout
                
            # Force kill thread if it's still alive
            if _server_thread and _server_thread.is_alive():
                # Reset thread reference
                _server_thread = None
        except Exception as e:
            print(format_message('stop_error', error=str(e)))
    
    # Try multiple shutdown methods for cross-process termination
    shutdown_success = False
    current_port = port
    
    # Method 1: Try graceful shutdown via control socket
    if not shutdown_success:
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(5)
                s.connect(('127.0.0.1', current_port + 1))
                s.sendall(b'SHUTDOWN')
                resp = s.recv(1024)
                if resp == b'OK':
                    shutdown_success = True
                    if not json_mode:
                        print("Server stopped successfully via shutdown listener")
        except (ConnectionRefusedError, OSError, socket.timeout):
            # Shutdown listener is not accessible, try other methods
            pass
    
    # Method 2: Try to kill process using psutil (if available)
    if not shutdown_success:
        try:
            import psutil
            killed_processes = []
            
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    # Look for Python processes running this server
                    if proc.info['name'] and 'python' in proc.info['name'].lower():
                        cmdline = proc.info['cmdline']
                        # More specific check: look for 'server.py' and server name in command line
                        if (cmdline and 
                            any('server.py' in str(arg) for arg in cmdline) and 
                            any('google_hotel' in str(arg).lower() for arg in cmdline)):
                            # Check if this process is using our port
                            try:
                                for conn in proc.net_connections():
                                    if conn.laddr.port == current_port:
                                        proc.terminate()
                                        killed_processes.append(proc.info['pid'])
                                        break
                            except (psutil.AccessDenied, psutil.NoSuchProcess):
                                continue
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            
            if killed_processes:
                # Wait a moment for processes to terminate
                time.sleep(2)
                if not is_port_in_use(current_port):
                    shutdown_success = True
                    if not json_mode:
                        print(f"Server stopped successfully (killed processes: {killed_processes})")
        except ImportError:
            # psutil not available, fall back to other methods
            pass
    
    # Method 3: Try netstat + taskkill (Windows specific)
    if not shutdown_success and os.name == 'nt':
        try:
            # Find process ID using netstat
            result = subprocess.run(
                f'netstat -ano | findstr ":{current_port}"',
                capture_output=True,
                text=True,
                shell=True
            )
            
            if result.returncode == 0 and result.stdout.strip():
                lines = result.stdout.strip().split('\n')
                pids = set()
                for line in lines:
                    parts = line.split()
                    if len(parts) >= 5:
                        pids.add(parts[-1])
                
                # Kill the processes
                for pid in pids:
                    try:
                        subprocess.run(['taskkill', '/PID', pid, '/F'], 
                                     capture_output=True, check=True)
                    except:
                        continue
                
                # Wait and check if port is free
                time.sleep(2)
                if not is_port_in_use(current_port):
                    shutdown_success = True
                    if not json_mode:
                        print(f"Server stopped successfully (killed PIDs: {', '.join(pids)})")
        except Exception:
            pass
    
    # Wait for port to be released
    max_wait = 5
    wait_count = 0
    while is_port_in_use(current_port) and wait_count < max_wait:
        time.sleep(1)
        wait_count += 1
    
    # Check if server is actually stopped
    if not is_port_in_use(current_port):
        if not json_mode:
            print(format_message('server_stopped'))
        return True
    else:
        if shutdown_success:
            if not json_mode:
                print(format_message('server_stopped'))
            return True
        else:
            if not json_mode:
                print(format_message('stop_fail'))
            return False

def is_server_running():
    """Check if the server is currently running."""
    # Check both internal flag and port usage for more accurate status
    return _server_running and is_port_in_use(google_hotel_PORT)

def is_port_in_use(port):
    """Check if a port is currently in use."""
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(1)  # Add timeout to avoid hanging
            result = s.connect_ex(('127.0.0.1', port))
            return result == 0
    except Exception:
        return False

def shutdown_listener(port):
    """Listen for a shutdown command on a local TCP socket."""
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        # Allow socket reuse to prevent "Address already in use" errors
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('127.0.0.1', port + 1))  # Use port + 1 for control
        sock.listen(1)
        sock.settimeout(1)  # Add timeout to make it responsive
        
        while _server_running:
            try:
                conn, addr = sock.accept()
                data = conn.recv(1024)
                if data == b'SHUTDOWN':
                    print("Shutdown command received via control socket")
                    stop_server(json_mode=False, port=port)  # Pass the port parameter
                    conn.sendall(b'OK')
                    conn.close()
                    break
                conn.close()
            except socket.timeout:
                # Continue loop to check _server_running flag
                continue
            except Exception:
                # Handle any other socket errors gracefully
                break
    except Exception as e:
        # Port might be in use or other socket error
        print(f"Shutdown listener could not start: {e}")
        # Continue without shutdown listener - other methods will still work
    finally:
        try:
            sock.close()
        except:
            pass

# Command line interface
if __name__ == "__main__":
    import json
    import argparse

    class ArgumentParserWithExceptions(argparse.ArgumentParser):
        def error(self, message):
            raise ValueError(message)
    
    def print_response(response, exit_code, json_output=False):
        """Print response and exit"""
        if json_output:
            print(json.dumps(response), flush=True)
        else:
            print(response["message"])
        sys.stdout.flush() 
        sys.exit(exit_code)
    
    # Set up argument parser
    parser = ArgumentParserWithExceptions(
        description="Search goolge hotel",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python server.py start
  python server.py start --json
  python server.py stop
  python server.py status --json
  python server.py ping
  python server.py version
        """
    )
    
    parser.add_argument("command", choices=["start", "stop", "status", "ping", "version", "help"])
    parser.add_argument("--json", action="store_true")
    parser.add_argument("--timeout", type=int, default=30)
    parser.add_argument("--port", type=int)
    parser.add_argument("--protocol", choices=["sse", "stdio", "http"], help="Communication protocol")
    
    try:
        args = parser.parse_args()
        
        # Configure logging based on output mode
        configure_logging(json_mode=args.json)
        
        current_port = google_hotel_PORT
        current_protocol = google_hotel_PROTOCOL
        if args.port:
            current_port = args.port
            os.environ[f'MCP_GOOGLE_HOTEL_PORT'] = str(current_port)
        if args.protocol:
            current_protocol = args.protocol
            os.environ[f'MCP_GOOGLE_HOTEL_PROTOCOL'] = current_protocol
            
        # Initialize FastMCP with the final port and protocol values
        mcp = FastMCP("google_hotel", port=current_port)
        # Register all tools with the MCP instance
        register_tools(verbose=not args.json)      
            
        def create_response(success, message, data=None, exit_code=0):
            """Create a standardized JSON response"""
            response = {
                "success": success,
                "message": message,
                "timestamp": int(time.time()),
                "port": current_port,
                "protocol": current_protocol,
            }
            if data:
                response["data"] = data
            return response, exit_code
        
        if args.command == "start":
            if start_server(current_port, current_protocol):
                response, exit_code = create_response(
                    True, 
                    format_message('server_started', port=current_port),
                    {"port": current_port},
                    exit_code=0 if _server_running else 1
                )
                
                if args.json:
                    print(json.dumps(response), flush=True)
        
                try:
                    while _server_running:
                        time.sleep(1)
                except KeyboardInterrupt:
                    print("\\nReceived interrupt signal")
                    stop_server(json_mode=args.json, port=current_port)
                    response, exit_code = create_response(True, format_message('interrupt'))
            else:
                response, exit_code = create_response(
                    False, 
                    format_message('server_start_fail'), 
                    exit_code=1
                )
                
        elif args.command == "stop":
            success = stop_server(json_mode=args.json, port=current_port)
            response, exit_code = create_response(
                success,
                format_message('stop_success' if success else 'stop_fail'),
                exit_code=0 if success else 1
            )
            
        elif args.command == "status":
            # For command line usage, check port usage since we're in a separate process
            running = is_port_in_use(current_port)
            msg_key = 'status_running' if running else 'status_stopped'
            response, exit_code = create_response(
                running,
                format_message(msg_key),
                {"status": "running" if running else "stopped", "port": current_port},
                0 if running else 1
            )
            
        elif args.command == "ping":
            # For command line usage, check port usage since we're in a separate process
            running = is_port_in_use(current_port)
            msg_key = 'ping_success' if running else 'ping_fail'
            response, exit_code = create_response(
                running,
                format_message(msg_key),
                {"status": "healthy" if running else "unhealthy", "port": current_port},
                0 if running else 1
            )
            
        elif args.command == "version":
            import platform
            version_info = {
                "version": "1.0.0",
                "python_version": platform.python_version(),
                "platform": platform.platform(),
                "port": current_port
            }
            response, exit_code = create_response(
                True, 
                format_message('version', version=version_info['version']), 
                version_info
            )
            
        elif args.command == "help":
            parser.print_help()
            sys.exit(0)
                
    except KeyboardInterrupt:
        response, exit_code = create_response(True, format_message('interrupt'))
    except Exception as e:
        response, exit_code = create_response(False, format_message('error', error=str(e)), exit_code=1)
    finally:
        if 'response' in locals():
            json_output = False
            if 'args' in locals() and hasattr(args, 'json'):
                json_output = args.json
            print_response(response, exit_code, json_output)