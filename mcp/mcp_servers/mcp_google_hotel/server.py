import os
import sys
import signal
import threading
import asyncio
import time
import socket
import subprocess
import json
import logging
from pathlib import Path
from mcp.server.fastmcp import FastMCP
from typing import List, Dict, Optional, Any
from serpapi import GoogleSearch
from rich.logging import RichHandler

# Message templates
SERVER_MESSAGES = {
    'server_start': 'google_hotel MCP server starting' + (' on port {port}' if 'http' != 'stdio' else ''),
    'server_started': 'google_hotel MCP server started successfully' + (' on port {port}' if 'http' != 'stdio' else ''),
    'server_stopped': 'google_hotel MCP server stopped',
    'server_start_fail': 'Failed to start google_hotel MCP server',
    'server_already_running': 'Server is already running',
    'server_not_running': 'Server is not running',
    'server_error': 'Server error: {error}',
    'start_error': 'Error starting server: {error}',
    'stop_error': 'Error stopping server: {error}',
    'stop_success': 'Server stopped successfully',
    'stop_fail': 'Server failed to stop',
    'status_running': 'google_hotel MCP server is running',
    'status_stopped': 'google_hotel MCP server is not running',
    'ping_success': 'Server is responding',
    'ping_fail': 'Server is not responding',
    'interrupt': 'Operation cancelled by user',
    'error': 'Error: {error}',
    'version': 'google_hotel MCP Server v{version}',
}

def format_message(key: str, **kwargs) -> str:
    """Format a server message with given parameters."""
    template = SERVER_MESSAGES.get(key, '')
    return template.format(**kwargs) if template else ''

# Load API Key
SERP_API_KEY = os.getenv("SERP_API_KEY")

# Configure logging for hotel search
def configure_logging(json_mode=False):
    """Configure logging based on output mode"""
    if json_mode:
        # In JSON mode, only log warnings and errors, redirect to stderr
        import sys
        handler = RichHandler(rich_tracebacks=True)
        handler.stream = sys.stderr
        logging.basicConfig(
            level=logging.WARNING,
            format="| %(levelname)-8s | %(name)s | %(message)s",
            datefmt="[%Y-%m-%d %H:%M:%S]",
            handlers=[handler],
            force=True
        )
    else:
        # In normal mode, use debug logging to stdout
        logging.basicConfig(
            level=logging.DEBUG,
            format="| %(levelname)-8s | %(name)s | %(message)s",
            datefmt="[%Y-%m-%d %H:%M:%S]",
            handlers=[RichHandler(rich_tracebacks=True)],
            force=True  # This overrides uvicorn & third-party loggers
        )

# Initialize with default logging (will be reconfigured based on args)
configure_logging()

logger = logging.getLogger("hotel_search")
logging.getLogger("uvicorn.access").setLevel(logging.INFO)
logging.getLogger("uvicorn.error").setLevel(logging.INFO)
logging.getLogger("httpx").setLevel(logging.WARNING)

def create_response(success, message, data=None, exit_code=0, current_port=None, current_protocol=None):
    """Create a standardized JSON response"""
    response = {
        "success": success,
        "message": message,
        "timestamp": int(time.time()),
        "protocol": current_protocol or google_hotel_PROTOCOL,
    }
    if (current_protocol or google_hotel_PROTOCOL) != 'stdio' and (current_port or google_hotel_PORT) is not None:
        response["port"] = current_port or google_hotel_PORT
    if data:
        response["data"] = data
    return response, exit_code

def create_response(success, message, data=None, exit_code=0, current_port=None, current_protocol=None):
    """Create a standardized JSON response"""
    response = {
        "success": success,
        "message": message,
        "timestamp": int(time.time()),
        "protocol": current_protocol or google_hotel_PROTOCOL,
    }
    if current_protocol != 'stdio' and current_port is not None:
        response["port"] = current_port
    if data:
        response["data"] = data
    return response, exit_code

# Initialize FastMCP server
# Generated by McpServerGen.py on 2025-09-02 11:27:24
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
google_hotel_PORT = int(os.getenv('MCP_GOOGLE_HOTEL_PORT', 7903)) if 'http' != 'stdio' else None
google_hotel_PROTOCOL = os.getenv('MCP_GOOGLE_HOTEL_PROTOCOL', 'http')
mcp = None  # Will be initialized after command line parsing

# Global variables for server management
_server_thread = None
_server_loop = None
_server_running = False
_server_start_time = None

#### Utility Functions ####

async def run_search(params: Dict[str, Any]):
    """
    Run SerpAPI search asynchronously.

    Args:
        params: Parameters for the SerpAPI search

    Returns:
        Search results from SerpAPI
    """
    try:
        logger.debug(
            f"Sending SerpAPI request with params: {json.dumps(params, indent=2)}"
        )
        result = await asyncio.to_thread(lambda: GoogleSearch(params).get_dict())
        logger.debug(f"SerpAPI response received, keys: {list(result.keys())}")
        return result
    except Exception as e:
        logger.exception(f"SerpAPI search error: {str(e)}")
        return {"error": str(e)}


def prepare_hotels_search_params(
    city: str,
    check_in_date: str,
    check_out_date: str,
    district: Optional[str] = "",
    adults: Optional[int] = 1,
    children: Optional[int] = 0,
    hotel_class: Optional[int] = 4,
) -> Dict[str, Any]:
    """
    Prepare parameters for a hotel search.

    Args:
        city: specify city name
        check_in_date: Check in date (YYYY-MM-DD)
        check_out_date: Check out date (YYYY-MM-DD)
        district:  the district where the hotel locates (default: "")
        adults: Number of adult passengers (default: 1)
        children: Number of children passengers (default: 0)
        hotel_class: defines to include only certain hotel class in the results (default: 4)

    Returns:
        Dictionary of parameters for SerpAPI
    """
    q = f"{city} hotel, {district} district" if district != "" else f"{city} hotel"
    params = {
        "api_key": SERP_API_KEY,
        "engine": "google_hotels",
        "hl": "en",
        "gl": "us",
        "q": q,
        "check_in_date": check_in_date,
        "check_out_date": check_out_date,
        "adults": adults,
        "children": children,
        "hotel_class": hotel_class,
        "currency": "USD",
    }
    logger.info(f"prepare_hotel_search_params: {params}")

    return params


def prepare_hotel_property_search_params(
    hotel_name: str,
    check_in_date: str,
    check_out_date: str,
    adults: Optional[int] = 1,
    children: Optional[int] = 0,
    hotel_class: Optional[int] = 4,
) -> Dict[str, Any]:
    """
    Prepare parameters for search property of a specific hotel.

    Args:
        hotel_name: the hotel name
        check_in_date: Check in date (YYYY-MM-DD)
        check_out_date: Check out date (YYYY-MM-DD)
        adults: Number of adult passengers (default: 1)
        children: Number of children passengers (default: 0)
        hotel_class: defines to include only certain hotel class in the results (default: 4)

    Returns:
        Dictionary of parameters for SerpAPI
    """
    params = {
        "api_key": SERP_API_KEY,
        "engine": "google_hotels",
        "hl": "en",
        "gl": "us",
        "q": hotel_name,
        "check_in_date": check_in_date,
        "check_out_date": check_out_date,
        "adults": adults,
        "children": children,
        "hotel_class": hotel_class,
        "currency": "USD",
    }
    logger.info(f"prepare_hotel_search_params: {params}")

    return params

#### Server Tools ####

async def search_hotel_tool(
    city: str,
    check_in_date: str,
    check_out_date: str,
    district: Optional[str] = "",
    adults: Optional[int] = 1,
    children: Optional[int] = 0,
    hotel_class: Optional[int] = 4,
):
    """
    Search for hotel using SerpAPI Google Hotel.

    This MCP tool allows AI models to search for hotel information by specifying
    departure and arrival airports and travel dates.

    Args:
        city: specify city name
        check_in_date: Check in date (YYYY-MM-DD)
        check_out_date: Check out date (YYYY-MM-DD)
        district:  the district where the hotel locates (default: "")
        adults: Number of adult passengers (default: 1)
        children: Number of children passengers (default: 0)
        hotel_class: defines to include only certain hotel class in the results (default: 4)

    Returns:
        A list of available hotel with details
    """
    logger.debug(
        f"Function called with: city={city}, check_in_date={check_in_date}, check_out_date={check_out_date}, district={district}, adults={adults}, children={children}, hotel_class={hotel_class}"
    )

    # Prepare search parameters
    params = prepare_hotels_search_params(
        city, check_in_date, check_out_date, district, adults, children, hotel_class
    )

    # Execute search
    logger.debug(f"Executing SerpAPI search for hotels in {city}...")

    search_results = await run_search(params)

    # Check for errors
    if "error" in search_results:
        logger.error(f"Hotel search error: {search_results['error']}")
        return {"error": search_results["error"]}

    # Process hotel results
    best_hotels = search_results.get("properties", [])
    logger.debug(f"Search complete. Found {len(best_hotels)} best hotels")

    if not best_hotels:
        logger.warning("No hotels found in search results")
        return []

    # Format hotel data
    formatted_hotels = []
    num_valid = 0
    for i, hotel in enumerate(best_hotels):
        if num_valid > 2:
            break
        logger.debug(f"Processing hotel {i+1} of {len(best_hotels)}")
        if not hotel.get("name"):
            logger.debug(f"Skipping hotel {i+1} as it has no hotel name")
            continue

        hotel_name = str(hotel.get("name"))
        # search address based on hotel_name
        property_params = prepare_hotel_property_search_params(
            hotel_name, check_in_date, check_out_date, adults, children, hotel_class
        )

        # Execute search
        logger.debug(f"Executing SerpAPI search for hotel {hotel_name}...")
        property_results = await run_search(property_params)
        # Check for errors
        if "error" in property_results:
            logger.error(
                f"Search hotel {hotel_name} got error: {property_results['error']}"
            )
            continue

        if "address" not in property_results:
            logger.debug(f"Skip hotel {hotel_name} since it has no address")
            continue

        rate_per_night = property_results.get("rate_per_night", {})
        total_rate = hotel.get("total_rate", {})

        link = str(property_results.get("link", "N/A"))
        print(f"@@@@link: {link}")

        # Add formatted hotels to results
        formatted_hotels.append(
            {
                "name": hotel_name,
                "address": str(property_results.get("address", "N/A")),
                "hotel_class": str(hotel.get("hotel_class", "N/A")),
                "rate_per_night": str(rate_per_night.get("lowest", "N/A")),
                "overall_rating": str(hotel.get("overall_rating", "N/A")),
                "link": str(property_results.get("link", "N/A")),
                # "check_in_time": str(hotel.get("check_in_time", "N/A")),
                # "check_out_time": str(hotel.get("check_out_time", "N/A"))
            }
        )
        num_valid += 1

    logger.info(f"Returning {len(formatted_hotels)} formatted hotels")
    return formatted_hotels

#### Tool Registration ####

# List of all tool functions to register
TOOL_FUNCTIONS = [
    search_hotel_tool,
    # Add additional tool functions here
]

def register_tools(verbose=True):
    """Register all tools with the MCP server."""
    global mcp
    if mcp is None:
        raise RuntimeError("MCP instance must be initialized before registering tools")
    
    for tool_func in TOOL_FUNCTIONS:
        mcp.tool()(tool_func)
        if verbose:
            print(f"Registered tool: {tool_func.__name__}")

#### Server management functions ####

def _run_server_in_thread(port, protocol):
    """Run the MCP server in a separate thread."""
    global _server_loop, _server_running
    
    _server_loop = asyncio.new_event_loop()
    asyncio.set_event_loop(_server_loop)
    
    try:
        _server_running = True
        if protocol == 'stdio':
            print(format_message('server_start'))
        else:
            print(format_message('server_start', port=port))
        mcp.run(transport="streamable-http" if protocol == "http" else protocol)
    except Exception as e:
        print(format_message('server_error', error=str(e)))
    finally:
        _server_running = False

def start_server(port=None, protocol=None):
    """Start the MCP server in a separate thread."""
    global _server_thread, _server_running, _server_start_time, mcp
    
    # Use provided parameters or fall back to global defaults
    if port is None:
        port = google_hotel_PORT
    if protocol is None:
        protocol = google_hotel_PROTOCOL
    
    # For stdio protocol, we don't need a port
    if protocol == 'stdio':
        port = None
    
    if (protocol == 'stdio' and mcp is None) or (protocol != 'stdio' and port != google_hotel_PORT):
        # Create fresh FastMCP instance with current port and protocol
        if protocol == 'stdio':
            mcp = FastMCP("google_hotel")
        else:
            mcp = FastMCP("google_hotel", port=port)
        # Register all tools with the new instance
        register_tools()
        
    try:
        # Check if server is already running
        if _server_running:
            print(format_message('server_already_running'))
            return False

        _server_thread = threading.Thread(target=_run_server_in_thread, args=(port, protocol), daemon=True)
        _server_thread.start()
        
        # Start shutdown listener in a separate daemon thread (only for non-stdio protocols)
        if protocol != 'stdio' and port is not None:
            threading.Thread(target=shutdown_listener, args=(port,), daemon=True).start()
        
        _server_start_time = time.time()
        
        time.sleep(2)  # Wait for server to start
        if _server_running:
            if protocol == 'stdio':
                print(format_message('server_started'))
            else:
                print(format_message('server_started', port=port))
            return True
        else:
            print(format_message('server_start_fail'))
            return False
    except Exception as e:
        print(format_message('start_error', error=str(e)))
        return False

def stop_server(json_mode=False, port=None):
    """Stop the MCP server using multiple reliable methods."""
    global _server_thread, _server_loop, _server_running

    # Use provided port or fall back to global default
    if port is None:
        port = google_hotel_PORT
    
    # For stdio protocol, port is None
    if google_hotel_PROTOCOL == 'stdio':
        port = None
    
    # First try to stop server started by this process
    if _server_running:
        try:
            _server_running = False
            
            # More aggressive shutdown
            if _server_loop and _server_loop.is_running():
                # Stop all running tasks in the loop
                for task in asyncio.all_tasks(_server_loop):
                    task.cancel()
                _server_loop.call_soon_threadsafe(_server_loop.stop)
            
            if _server_thread and _server_thread.is_alive():
                _server_thread.join(timeout=10)  # Increased timeout
                
            # Force kill thread if it's still alive
            if _server_thread and _server_thread.is_alive():
                # Reset thread reference
                _server_thread = None
        except Exception as e:
            print(format_message('stop_error', error=str(e)))
    
    # Try multiple shutdown methods for cross-process termination (skip for stdio)
    shutdown_success = False
    current_port = port
    
    # Skip port-based shutdown methods for stdio protocol
    if current_port is not None:
        # Method 1: Try graceful shutdown via control socket
        if not shutdown_success:
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(5)
                    s.connect(('127.0.0.1', current_port + 1))
                    s.sendall(b'SHUTDOWN')
                    resp = s.recv(1024)
                    if resp == b'OK':
                        shutdown_success = True
                        if not json_mode:
                            print("Server stopped successfully via shutdown listener")
            except (ConnectionRefusedError, OSError, socket.timeout):
                # Shutdown listener is not accessible, try other methods
                pass
    
        # Method 2: Try to kill process using psutil (if available)
        if not shutdown_success and current_port is not None:
            try:
                import psutil
                killed_processes = []
                
                for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                    try:
                        # Look for Python processes running this server
                        if proc.info['name'] and 'python' in proc.info['name'].lower():
                            cmdline = proc.info['cmdline']
                            # More specific check: look for 'server.py' and server name in command line
                            if (cmdline and 
                                any('server.py' in str(arg) for arg in cmdline) and 
                                any('google_hotel' in str(arg).lower() for arg in cmdline)):
                                # Check if this process is using our port
                                try:
                                    for conn in proc.net_connections():
                                        if conn.laddr.port == current_port:
                                            proc.terminate()
                                            killed_processes.append(proc.info['pid'])
                                            break
                                except (psutil.AccessDenied, psutil.NoSuchProcess):
                                    continue
                    except (psutil.NoSuchProcess, psutil.AccessDenied):
                        continue
                
                if killed_processes:
                    # Wait a moment for processes to terminate
                    time.sleep(2)
                    if not is_port_in_use(current_port):
                        shutdown_success = True
                        if not json_mode:
                            print(f"Server stopped successfully (killed processes: {killed_processes})")
            except ImportError:
                # psutil not available, fall back to other methods
                pass
        
        # Method 3: Try netstat + taskkill (Windows specific)
        if not shutdown_success and current_port is not None and os.name == 'nt':
            try:
                # Find process ID using netstat
                result = subprocess.run(
                    f'netstat -ano | findstr ":{current_port}"',
                    capture_output=True,
                    text=True,
                    shell=True
                )
                
                if result.returncode == 0 and result.stdout.strip():
                    lines = result.stdout.strip().split('\n')
                    pids = set()
                    for line in lines:
                        parts = line.split()
                        if len(parts) >= 5:
                            pids.add(parts[-1])
                    
                    # Kill the processes
                    for pid in pids:
                        try:
                            subprocess.run(['taskkill', '/PID', pid, '/F'], 
                                         capture_output=True, check=True)
                        except:
                            continue
                    
                    # Wait and check if port is free
                    time.sleep(2)
                    if not is_port_in_use(current_port):
                        shutdown_success = True
                        if not json_mode:
                            print(f"Server stopped successfully (killed PIDs: {', '.join(pids)})")
            except Exception:
                pass
    
    # For protocols with ports, wait for port to be released
    if current_port is not None:
        max_wait = 5
        wait_count = 0
        while is_port_in_use(current_port) and wait_count < max_wait:
            time.sleep(1)
            wait_count += 1
    
    # Check if server is actually stopped
    if current_port is None:  # stdio protocol
        # For stdio, just check if the internal process stopped
        if not _server_running:
            if not json_mode:
                print(format_message('server_stopped'))
            return True
        else:
            if not json_mode:
                print(format_message('stop_fail'))
            return False
    elif not is_port_in_use(current_port):  # port-based protocols
        if not json_mode:
            print(format_message('server_stopped'))
        return True
    else:
        if shutdown_success:
            if not json_mode:
                print(format_message('server_stopped'))
            return True
        else:
            if not json_mode:
                print(format_message('stop_fail'))
            return False

def is_server_running():
    """Check if the server is currently running."""
    # For stdio protocol, only check the internal flag since there's no port
    if google_hotel_PROTOCOL == 'stdio':
        return _server_running
    # For other protocols, check both internal flag and port usage for more accurate status
    return _server_running and is_port_in_use(google_hotel_PORT)

def is_port_in_use(port):
    """Check if a port is currently in use."""
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(1)  # Add timeout to avoid hanging
            result = s.connect_ex(('127.0.0.1', port))
            return result == 0
    except Exception:
        return False

def shutdown_listener(port):
    """Listen for a shutdown command on a local TCP socket."""
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        # Allow socket reuse to prevent "Address already in use" errors
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('127.0.0.1', port + 1))  # Use port + 1 for control
        sock.listen(1)
        sock.settimeout(1)  # Add timeout to make it responsive
        
        while _server_running:
            try:
                conn, addr = sock.accept()
                data = conn.recv(1024)
                if data == b'SHUTDOWN':
                    print("Shutdown command received via control socket")
                    stop_server(json_mode=False, port=port)  # Pass the port parameter
                    conn.sendall(b'OK')
                    conn.close()
                    break
                conn.close()
            except socket.timeout:
                # Continue loop to check _server_running flag
                continue
            except Exception:
                # Handle any other socket errors gracefully
                break
    except Exception as e:
        # Port might be in use or other socket error
        print(f"Shutdown listener could not start: {e}")
        # Continue without shutdown listener - other methods will still work
    finally:
        try:
            sock.close()
        except:
            pass

# Command line interface
if __name__ == "__main__":
    import json
    import argparse

    class ArgumentParserWithExceptions(argparse.ArgumentParser):
        def error(self, message):
            raise ValueError(message)
    
    def print_response(response, exit_code, json_output=False):
        """Print response and exit"""
        if json_output:
            print(json.dumps(response), flush=True)
        else:
            print(response["message"])
        sys.stdout.flush() 
        sys.exit(exit_code)
    
    # Set up argument parser
    parser = ArgumentParserWithExceptions(
        description="Search google hotels",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python server.py start
  python server.py start --json
  python server.py stop
  python server.py status --json
  python server.py ping
  python server.py version
        """
    )
    
    parser.add_argument("command", choices=["start", "stop", "status", "ping", "version", "help"])
    parser.add_argument("--json", action="store_true")
    parser.add_argument("--timeout", type=int, default=30)
    parser.add_argument("--port", type=int)
    parser.add_argument("--protocol", choices=["sse", "stdio", "http"], help="Communication protocol")
    
    try:
        args = parser.parse_args()
        
        # Configure logging based on output mode
        configure_logging(json_mode=args.json)
        
        current_port = google_hotel_PORT
        current_protocol = google_hotel_PROTOCOL
        if args.port:
            current_port = args.port
            os.environ[f'MCP_GOOGLE_HOTEL_PORT'] = str(current_port)
        if args.protocol:
            current_protocol = args.protocol
            os.environ[f'MCP_GOOGLE_HOTEL_PROTOCOL'] = current_protocol
        
        # For stdio protocol, ignore port setting
        if current_protocol == 'stdio':
            current_port = None
            
        # Initialize FastMCP with the final port and protocol values
        if current_protocol == 'stdio':
            mcp = FastMCP("google_hotel")
        else:
            mcp = FastMCP("google_hotel", port=current_port)
        # Register all tools with the MCP instance
        register_tools(verbose=not args.json)      
            
        if args.command == "start":
            if start_server(current_port, current_protocol):
                if current_protocol == 'stdio':
                    response, exit_code = create_response(
                        True, 
                        format_message('server_started'),
                        {},
                        exit_code=0 if _server_running else 1,
                        current_port=current_port,
                        current_protocol=current_protocol
                    )
                else:
                    response, exit_code = create_response(
                        True, 
                        format_message('server_started', port=current_port),
                        {"port": current_port},
                        exit_code=0 if _server_running else 1,
                        current_port=current_port,
                        current_protocol=current_protocol
                    )
                
                if args.json:
                    print(json.dumps(response), flush=True)
        
                try:
                    while _server_running:
                        time.sleep(1)
                except KeyboardInterrupt:
                    print("\\nReceived interrupt signal")
                    stop_server(json_mode=args.json, port=current_port)
                    response, exit_code = create_response(
                        True, 
                        format_message('interrupt'),
                        current_port=current_port,
                        current_protocol=current_protocol
                    )
            else:
                response, exit_code = create_response(
                    False, 
                    format_message('server_start_fail'), 
                    exit_code=1,
                    current_port=current_port,
                    current_protocol=current_protocol
                )
                
        elif args.command == "stop":
            success = stop_server(json_mode=args.json, port=current_port)
            response, exit_code = create_response(
                success,
                format_message('stop_success' if success else 'stop_fail'),
                exit_code=0 if success else 1,
                current_port=current_port,
                current_protocol=current_protocol
            )
            
        elif args.command == "status":
            # For command line usage, check appropriate method based on protocol
            if current_protocol == 'stdio':
                # For stdio, we can't easily check if another process is running
                # so we'll just report based on what we can detect
                running = False  # Default to not running for separate process
                status_data = {"status": "running" if running else "stopped", "protocol": current_protocol}
            else:
                running = is_port_in_use(current_port)
                status_data = {"status": "running" if running else "stopped", "port": current_port, "protocol": current_protocol}
            
            msg_key = 'status_running' if running else 'status_stopped'
            response, exit_code = create_response(
                running,
                format_message(msg_key),
                status_data,
                0 if running else 1,
                current_port=current_port,
                current_protocol=current_protocol
            )
            
        elif args.command == "ping":
            # For command line usage, check appropriate method based on protocol
            if current_protocol == 'stdio':
                # For stdio, we can't easily ping another process
                running = False  # Default to not running for separate process
                ping_data = {"status": "healthy" if running else "unhealthy", "protocol": current_protocol}
            else:
                running = is_port_in_use(current_port)
                ping_data = {"status": "healthy" if running else "unhealthy", "port": current_port, "protocol": current_protocol}
            
            msg_key = 'ping_success' if running else 'ping_fail'
            response, exit_code = create_response(
                running,
                format_message(msg_key),
                ping_data,
                0 if running else 1,
                current_port=current_port,
                current_protocol=current_protocol
            )
            
        elif args.command == "version":
            import platform
            version_info = {
                "version": "1.0.0",
                "python_version": platform.python_version(),
                "platform": platform.platform(),
                "protocol": current_protocol
            }
            if current_protocol != 'stdio' and current_port is not None:
                version_info["port"] = current_port
            response, exit_code = create_response(
                True, 
                format_message('version', version=version_info['version']), 
                version_info,
                current_port=current_port,
                current_protocol=current_protocol
            )
            
        elif args.command == "help":
            parser.print_help()
            sys.exit(0)
                
    except KeyboardInterrupt:
        # Use defaults if variables are not defined
        current_port_safe = locals().get('current_port', google_hotel_PORT)
        current_protocol_safe = locals().get('current_protocol', google_hotel_PROTOCOL)
        response, exit_code = create_response(
            True, 
            format_message('interrupt'),
            current_port=current_port_safe,
            current_protocol=current_protocol_safe
        )
    except Exception as e:
        # Use defaults if variables are not defined
        current_port_safe = locals().get('current_port', google_hotel_PORT)
        current_protocol_safe = locals().get('current_protocol', google_hotel_PROTOCOL)
        response, exit_code = create_response(
            False, 
            format_message('error', error=str(e)), 
            exit_code=1,
            current_port=current_port_safe,
            current_protocol=current_protocol_safe
        )
    finally:
        if 'response' in locals():
            json_output = False
            if 'args' in locals() and hasattr(args, 'json'):
                json_output = args.json
            print_response(response, exit_code, json_output)