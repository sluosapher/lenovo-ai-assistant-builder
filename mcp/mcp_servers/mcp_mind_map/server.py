import os
import sys
import signal
import threading
import asyncio
import time
import socket
import subprocess
from pathlib import Path
from mcp.server.fastmcp import FastMCP

# Message templates
SERVER_MESSAGES = {
    'server_start': 'mind_map MCP server starting' + (' on port {port}' if 'stdio' != 'stdio' else ''),
    'server_started': 'mind_map MCP server started successfully' + (' on port {port}' if 'stdio' != 'stdio' else ''),
    'server_stopped': 'mind_map MCP server stopped',
    'server_start_fail': 'Failed to start mind_map MCP server',
    'server_already_running': 'Server is already running',
    'server_not_running': 'Server is not running',
    'server_error': 'Server error: {error}',
    'start_error': 'Error starting server: {error}',
    'stop_error': 'Error stopping server: {error}',
    'stop_success': 'Server stopped successfully',
    'stop_fail': 'Server failed to stop',
    'status_running': 'mind_map MCP server is running',
    'status_stopped': 'mind_map MCP server is not running',
    'ping_success': 'Server is responding',
    'ping_fail': 'Server is not responding',
    'interrupt': 'Operation cancelled by user',
    'error': 'Error: {error}',
    'version': 'mind_map MCP Server v{version}',
}

def format_message(key: str, **kwargs) -> str:
    """Format a server message with given parameters."""
    template = SERVER_MESSAGES.get(key, '')
    return template.format(**kwargs) if template else ''

def create_response(success, message, data=None, exit_code=0, current_port=None, current_protocol=None):
    """Create a standardized JSON response"""
    response = {
        "success": success,
        "message": message,
        "timestamp": int(time.time()),
        "protocol": current_protocol or mind_map_PROTOCOL,
    }
    if current_protocol != 'stdio' and current_port is not None:
        response["port"] = current_port
    if data:
        response["data"] = data
    return response, exit_code

# Initialize FastMCP server
# Generated by McpServerGen.py on 2025-09-02 10:33:05
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
mind_map_PORT = int(os.getenv('MCP_MIND_MAP_PORT', 7905)) if 'stdio' != 'stdio' else None
mind_map_PROTOCOL = os.getenv('MCP_MIND_MAP_PROTOCOL', 'stdio')
mcp = None  # Will be initialized after command line parsing

# Global variables for server management
_server_thread = None
_server_loop = None
_server_running = False
_server_start_time = None

#### Server Tools ####

# check if the required dependencies are installed
def is_markmap_installed():
    try:
        result = subprocess.run(
            ["markmap", "--version"],
            capture_output=True,
            text=True,
            shell=True
        )
        return result.returncode == 0
    except Exception:
        return False

if not is_markmap_installed():
    raise RuntimeError(
        "markmap-cli is not installed or not found in PATH. "
        "Please install it with 'npm install -g markmap-cli'."
    )

async def convert_markdown_file_to_mindmap(
    markdown_file: str,  # The Markdown file to convert
) -> str:
    """Convert Markdown content to a mindmap mind map.
    
    Args:
        markdown_file: The path of the Markdown file
    
    Returns:
        the file path to the generated HTML
    """
    try:
        
        markdown_file = markdown_file.replace('"', '').replace("'", "")
        markdown_file : Path = Path(markdown_file)
        if not markdown_file.exists():
            raise RuntimeError(f"Markdown file does not exist: {markdown_file}")
        if not markdown_file.suffix == '.md':
            raise RuntimeError(f"File is not a Markdown file: {markdown_file}")
        
        process = subprocess.run(
            [
                "powershell.exe",
                "-Command",
                f'markmap.ps1 "{str(markdown_file)}" --no-open'
            ],
            capture_output=True,
            text=True
        )
        output_file: Path = Path(str(markdown_file).replace(".md", ".html"))
        
        if process.returncode != 0:
            raise RuntimeError(f"markmap-cli exited with code {process.returncode}: {process.stderr}")
        
        # by default, output file is at the same folder as input file
        if not output_file.exists():
            raise RuntimeError(f"Output file was not created: {output_file}")
        
        return str(output_file)
        
    except Exception as e:
        raise RuntimeError(f"Error converting Markdown to mindmap: {str(e)}")

#### Tool Registration ####

# List of all tool functions to register
TOOL_FUNCTIONS = [
    convert_markdown_file_to_mindmap,
    # Add additional tool functions here
]

def register_tools(verbose=True):
    """Register all tools with the MCP server."""
    global mcp
    if mcp is None:
        raise RuntimeError("MCP instance must be initialized before registering tools")
    
    for tool_func in TOOL_FUNCTIONS:
        mcp.tool()(tool_func)
        if verbose:
            print(f"Registered tool: {tool_func.__name__}")

#### Server management functions ####

def _run_server_in_thread(port, protocol):
    """Run the MCP server in a separate thread."""
    global _server_loop, _server_running
    
    _server_loop = asyncio.new_event_loop()
    asyncio.set_event_loop(_server_loop)
    
    try:
        _server_running = True
        if protocol == 'stdio':
            print(format_message('server_start'))
        else:
            print(format_message('server_start', port=port))
        mcp.run(transport="streamable-http" if protocol == "http" else protocol)
    except Exception as e:
        print(format_message('server_error', error=str(e)))
    finally:
        _server_running = False

def start_server(port=None, protocol=None):
    """Start the MCP server in a separate thread."""
    global _server_thread, _server_running, _server_start_time, mcp
    
    # Use provided parameters or fall back to global defaults
    if port is None:
        port = mind_map_PORT
    if protocol is None:
        protocol = mind_map_PROTOCOL
    
    # For stdio protocol, we don't need a port
    if protocol == 'stdio':
        port = None
    
    if (protocol == 'stdio' and mcp is None) or (protocol != 'stdio' and port != mind_map_PORT):
        # Create fresh FastMCP instance with current port and protocol
        if protocol == 'stdio':
            mcp = FastMCP("mind_map")
        else:
            mcp = FastMCP("mind_map", port=port)
        # Register all tools with the new instance
        register_tools()
        
    try:
        # Check if server is already running
        if _server_running:
            print(format_message('server_already_running'))
            return False

        _server_thread = threading.Thread(target=_run_server_in_thread, args=(port, protocol), daemon=True)
        _server_thread.start()
        
        # Start shutdown listener in a separate daemon thread (only for non-stdio protocols)
        if protocol != 'stdio' and port is not None:
            threading.Thread(target=shutdown_listener, args=(port,), daemon=True).start()
        
        _server_start_time = time.time()
        
        time.sleep(2)  # Wait for server to start
        if _server_running:
            if protocol == 'stdio':
                print(format_message('server_started'))
            else:
                print(format_message('server_started', port=port))
            return True
        else:
            print(format_message('server_start_fail'))
            return False
    except Exception as e:
        print(format_message('start_error', error=str(e)))
        return False

def stop_server(json_mode=False, port=None):
    """Stop the MCP server using multiple reliable methods."""
    global _server_thread, _server_loop, _server_running

    # Use provided port or fall back to global default
    if port is None:
        port = mind_map_PORT
    
    # For stdio protocol, port is None
    if mind_map_PROTOCOL == 'stdio':
        port = None
    
    # First try to stop server started by this process
    if _server_running:
        try:
            _server_running = False
            
            # More aggressive shutdown
            if _server_loop and _server_loop.is_running():
                # Stop all running tasks in the loop
                for task in asyncio.all_tasks(_server_loop):
                    task.cancel()
                _server_loop.call_soon_threadsafe(_server_loop.stop)
            
            if _server_thread and _server_thread.is_alive():
                _server_thread.join(timeout=10)  # Increased timeout
                
            # Force kill thread if it's still alive
            if _server_thread and _server_thread.is_alive():
                # Reset thread reference
                _server_thread = None
        except Exception as e:
            print(format_message('stop_error', error=str(e)))
    
    # Try multiple shutdown methods for cross-process termination (skip for stdio)
    shutdown_success = False
    current_port = port
    
    # Skip port-based shutdown methods for stdio protocol
    if current_port is not None:
        # Method 1: Try graceful shutdown via control socket
        if not shutdown_success:
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(5)
                    s.connect(('127.0.0.1', current_port + 1))
                    s.sendall(b'SHUTDOWN')
                    resp = s.recv(1024)
                    if resp == b'OK':
                        shutdown_success = True
                        if not json_mode:
                            print("Server stopped successfully via shutdown listener")
            except (ConnectionRefusedError, OSError, socket.timeout):
                # Shutdown listener is not accessible, try other methods
                pass
    
        # Method 2: Try to kill process using psutil (if available)
        if not shutdown_success and current_port is not None:
            try:
                import psutil
                killed_processes = []
                
                for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                    try:
                        # Look for Python processes running this server
                        if proc.info['name'] and 'python' in proc.info['name'].lower():
                            cmdline = proc.info['cmdline']
                            # More specific check: look for 'server.py' and server name in command line
                            if (cmdline and 
                                any('server.py' in str(arg) for arg in cmdline) and 
                                any('mind_map' in str(arg).lower() for arg in cmdline)):
                                # Check if this process is using our port
                                try:
                                    for conn in proc.net_connections():
                                        if conn.laddr.port == current_port:
                                            proc.terminate()
                                            killed_processes.append(proc.info['pid'])
                                            break
                                except (psutil.AccessDenied, psutil.NoSuchProcess):
                                    continue
                    except (psutil.NoSuchProcess, psutil.AccessDenied):
                        continue
                
                if killed_processes:
                    # Wait a moment for processes to terminate
                    time.sleep(2)
                    if not is_port_in_use(current_port):
                        shutdown_success = True
                        if not json_mode:
                            print(f"Server stopped successfully (killed processes: {killed_processes})")
            except ImportError:
                # psutil not available, fall back to other methods
                pass
        
        # Method 3: Try netstat + taskkill (Windows specific)
        if not shutdown_success and current_port is not None and os.name == 'nt':
            try:
                # Find process ID using netstat
                result = subprocess.run(
                    f'netstat -ano | findstr ":{current_port}"',
                    capture_output=True,
                    text=True,
                    shell=True
                )
                
                if result.returncode == 0 and result.stdout.strip():
                    lines = result.stdout.strip().split('\n')
                    pids = set()
                    for line in lines:
                        parts = line.split()
                        if len(parts) >= 5:
                            pids.add(parts[-1])
                    
                    # Kill the processes
                    for pid in pids:
                        try:
                            subprocess.run(['taskkill', '/PID', pid, '/F'], 
                                         capture_output=True, check=True)
                        except:
                            continue
                    
                    # Wait and check if port is free
                    time.sleep(2)
                    if not is_port_in_use(current_port):
                        shutdown_success = True
                        if not json_mode:
                            print(f"Server stopped successfully (killed PIDs: {', '.join(pids)})")
            except Exception:
                pass
    
    # For protocols with ports, wait for port to be released
    if current_port is not None:
        max_wait = 5
        wait_count = 0
        while is_port_in_use(current_port) and wait_count < max_wait:
            time.sleep(1)
            wait_count += 1
    
    # Check if server is actually stopped
    if current_port is None:  # stdio protocol
        # For stdio, just check if the internal process stopped
        if not _server_running:
            if not json_mode:
                print(format_message('server_stopped'))
            return True
        else:
            if not json_mode:
                print(format_message('stop_fail'))
            return False
    elif not is_port_in_use(current_port):  # port-based protocols
        if not json_mode:
            print(format_message('server_stopped'))
        return True
    else:
        if shutdown_success:
            if not json_mode:
                print(format_message('server_stopped'))
            return True
        else:
            if not json_mode:
                print(format_message('stop_fail'))
            return False

def is_server_running():
    """Check if the server is currently running."""
    # For stdio protocol, only check the internal flag since there's no port
    if mind_map_PROTOCOL == 'stdio':
        return _server_running
    # For other protocols, check both internal flag and port usage for more accurate status
    return _server_running and is_port_in_use(mind_map_PORT)

def is_port_in_use(port):
    """Check if a port is currently in use."""
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(1)  # Add timeout to avoid hanging
            result = s.connect_ex(('127.0.0.1', port))
            return result == 0
    except Exception:
        return False

def shutdown_listener(port):
    """Listen for a shutdown command on a local TCP socket."""
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        # Allow socket reuse to prevent "Address already in use" errors
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('127.0.0.1', port + 1))  # Use port + 1 for control
        sock.listen(1)
        sock.settimeout(1)  # Add timeout to make it responsive
        
        while _server_running:
            try:
                conn, addr = sock.accept()
                data = conn.recv(1024)
                if data == b'SHUTDOWN':
                    print("Shutdown command received via control socket")
                    stop_server(json_mode=False, port=port)  # Pass the port parameter
                    conn.sendall(b'OK')
                    conn.close()
                    break
                conn.close()
            except socket.timeout:
                # Continue loop to check _server_running flag
                continue
            except Exception:
                # Handle any other socket errors gracefully
                break
    except Exception as e:
        # Port might be in use or other socket error
        print(f"Shutdown listener could not start: {e}")
        # Continue without shutdown listener - other methods will still work
    finally:
        try:
            sock.close()
        except:
            pass

# Command line interface
if __name__ == "__main__":
    import json
    import argparse

    class ArgumentParserWithExceptions(argparse.ArgumentParser):
        def error(self, message):
            raise ValueError(message)
    
    def print_response(response, exit_code, json_output=False):
        """Print response and exit"""
        if json_output:
            print(json.dumps(response), flush=True)
        else:
            print(response["message"])
        sys.stdout.flush() 
        sys.exit(exit_code)
    
    # Set up argument parser
    parser = ArgumentParserWithExceptions(
        description="Create Mind Map",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python server.py start
  python server.py start --json
  python server.py stop
  python server.py status --json
  python server.py ping
  python server.py version
        """
    )
    
    parser.add_argument("command", choices=["start", "stop", "status", "ping", "version", "help"])
    parser.add_argument("--json", action="store_true")
    parser.add_argument("--timeout", type=int, default=30)
    parser.add_argument("--port", type=int)
    parser.add_argument("--protocol", choices=["sse", "stdio", "http"], help="Communication protocol")
    
    try:
        args = parser.parse_args()
        
        current_port = mind_map_PORT
        current_protocol = mind_map_PROTOCOL
        if args.port:
            current_port = args.port
            os.environ[f'MCP_MIND_MAP_PORT'] = str(current_port)
        if args.protocol:
            current_protocol = args.protocol
            os.environ[f'MCP_MIND_MAP_PROTOCOL'] = current_protocol
        
        # For stdio protocol, ignore port setting
        if current_protocol == 'stdio':
            current_port = None
            
        # Initialize FastMCP with the final port and protocol values
        if current_protocol == 'stdio':
            mcp = FastMCP("mind_map")
        else:
            mcp = FastMCP("mind_map", port=current_port)
        # Register all tools with the MCP instance
        register_tools(verbose=not args.json)      
            
        if args.command == "start":
            if start_server(current_port, current_protocol):
                if current_protocol == 'stdio':
                    response, exit_code = create_response(
                        True, 
                        format_message('server_started'),
                        {},
                        exit_code=0 if _server_running else 1,
                        current_port=current_port,
                        current_protocol=current_protocol
                    )
                else:
                    response, exit_code = create_response(
                        True, 
                        format_message('server_started', port=current_port),
                        {"port": current_port},
                        exit_code=0 if _server_running else 1,
                        current_port=current_port,
                        current_protocol=current_protocol
                    )
                
                if args.json:
                    print(json.dumps(response), flush=True)
        
                try:
                    while _server_running:
                        time.sleep(1)
                except KeyboardInterrupt:
                    print("\\nReceived interrupt signal")
                    stop_server(json_mode=args.json, port=current_port)
                    response, exit_code = create_response(
                        True, 
                        format_message('interrupt'),
                        current_port=current_port,
                        current_protocol=current_protocol
                    )
            else:
                response, exit_code = create_response(
                    False, 
                    format_message('server_start_fail'), 
                    exit_code=1,
                    current_port=current_port,
                    current_protocol=current_protocol
                )
                
        elif args.command == "stop":
            success = stop_server(json_mode=args.json, port=current_port)
            response, exit_code = create_response(
                success,
                format_message('stop_success' if success else 'stop_fail'),
                exit_code=0 if success else 1,
                current_port=current_port,
                current_protocol=current_protocol
            )
            
        elif args.command == "status":
            # For command line usage, check appropriate method based on protocol
            if current_protocol == 'stdio':
                # For stdio, we can't easily check if another process is running
                # so we'll just report based on what we can detect
                running = False  # Default to not running for separate process
                status_data = {"status": "running" if running else "stopped", "protocol": current_protocol}
            else:
                running = is_port_in_use(current_port)
                status_data = {"status": "running" if running else "stopped", "port": current_port, "protocol": current_protocol}
            
            msg_key = 'status_running' if running else 'status_stopped'
            response, exit_code = create_response(
                running,
                format_message(msg_key),
                status_data,
                0 if running else 1,
                current_port=current_port,
                current_protocol=current_protocol
            )
            
        elif args.command == "ping":
            # For command line usage, check appropriate method based on protocol
            if current_protocol == 'stdio':
                # For stdio, we can't easily ping another process
                running = False  # Default to not running for separate process
                ping_data = {"status": "healthy" if running else "unhealthy", "protocol": current_protocol}
            else:
                running = is_port_in_use(current_port)
                ping_data = {"status": "healthy" if running else "unhealthy", "port": current_port, "protocol": current_protocol}
            
            msg_key = 'ping_success' if running else 'ping_fail'
            response, exit_code = create_response(
                running,
                format_message(msg_key),
                ping_data,
                0 if running else 1,
                current_port=current_port,
                current_protocol=current_protocol
            )
            
        elif args.command == "version":
            import platform
            version_info = {
                "version": "1.0.0",
                "python_version": platform.python_version(),
                "platform": platform.platform(),
                "protocol": current_protocol
            }
            if current_protocol != 'stdio' and current_port is not None:
                version_info["port"] = current_port
            response, exit_code = create_response(
                True, 
                format_message('version', version=version_info['version']), 
                version_info,
                current_port=current_port,
                current_protocol=current_protocol
            )
            
        elif args.command == "help":
            parser.print_help()
            sys.exit(0)
                
    except KeyboardInterrupt:
        # Use defaults if variables are not defined
        current_port_safe = locals().get('current_port', mind_map_PORT)
        current_protocol_safe = locals().get('current_protocol', mind_map_PROTOCOL)
        response, exit_code = create_response(
            True, 
            format_message('interrupt'),
            current_port=current_port_safe,
            current_protocol=current_protocol_safe
        )
    except Exception as e:
        # Use defaults if variables are not defined
        current_port_safe = locals().get('current_port', mind_map_PORT)
        current_protocol_safe = locals().get('current_protocol', mind_map_PROTOCOL)
        response, exit_code = create_response(
            False, 
            format_message('error', error=str(e)), 
            exit_code=1,
            current_port=current_port_safe,
            current_protocol=current_protocol_safe
        )
    finally:
        if 'response' in locals():
            json_output = False
            if 'args' in locals() and hasattr(args, 'json'):
                json_output = args.json
            print_response(response, exit_code, json_output)