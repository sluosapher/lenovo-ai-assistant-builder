import os
import sys
import signal
import threading
import asyncio
import time
import socket
import subprocess
from pathlib import Path
from mcp.server.fastmcp import FastMCP

# Message templates
SERVER_MESSAGES = {
    'server_start': 'mind_map MCP server starting on port {port}',
    'server_started': 'mind_map MCP server started successfully on port {port}',
    'server_stopped': 'mind_map MCP server stopped',
    'server_start_fail': 'Failed to start mind_map MCP server',
    'server_already_running': 'Server is already running',
    'server_not_running': 'Server is not running',
    'server_error': 'Server error: {error}',
    'start_error': 'Error starting server: {error}',
    'stop_error': 'Error stopping server: {error}',
    'stop_success': 'Server stopped successfully',
    'stop_fail': 'Server failed to stop',
    'status_running': 'mind_map MCP server is running',
    'status_stopped': 'mind_map MCP server is not running',
    'ping_success': 'Server is responding',
    'ping_fail': 'Server is not responding',
    'interrupt': 'Operation cancelled by user',
    'error': 'Error: {error}',
    'version': 'mind_map MCP Server v{version}',
}

def format_message(key: str, **kwargs) -> str:
    """Format a server message with given parameters."""
    template = SERVER_MESSAGES.get(key, '')
    return template.format(**kwargs) if template else ''

# Initialize FastMCP server
# Generated by McpServerGen.py on 2025-07-29 11:33:19
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
mind_map_PORT = int(os.getenv('MCP_MIND_MAP_PORT', 7907))
mind_map_PROTOCOL = os.getenv('MCP_MIND_MAP_PROTOCOL', 'sse')
mcp = None  # Will be initialized after command line parsing

# Global variables for server management
_server_thread = None
_server_loop = None
_server_running = False
_server_start_time = None

#### Server Tools ####

# check if the required dependencies are installed
def is_markmap_installed():
    try:
        result = subprocess.run(
            ["markmap", "--version"],
            capture_output=True,
            text=True,
            shell=True
        )
        return result.returncode == 0
    except Exception:
        return False

if not is_markmap_installed():
    raise RuntimeError(
        "markmap-cli is not installed or not found in PATH. "
        "Please install it with 'npm install -g markmap-cli'."
    )

async def convert_markdown_file_to_mindmap(
    markdown_file: str,  # The Markdown file to convert
) -> str:
    """Convert Markdown content to a mindmap mind map.
    
    Args:
        markdown_file: The path of the Markdown file
    
    Returns:
        the file path to the generated HTML
    """
    try:
        
        markdown_file = markdown_file.replace('"', '').replace("'", "")
        markdown_file : Path = Path(markdown_file)
        if not markdown_file.exists():
            raise RuntimeError(f"Markdown file does not exist: {markdown_file}")
        if not markdown_file.suffix == '.md':
            raise RuntimeError(f"File is not a Markdown file: {markdown_file}")
        
        command_to_run = f"markmap.ps1 {markdown_file} --no-open"
        args = ['powershell.exe', '-Command', command_to_run ]
        command = " ".join(args)

        process = subprocess.run(command, capture_output=True, text=True, shell=True)
        output_file: Path = Path(str(markdown_file).replace(".md", ".html"))
        
        if process.returncode != 0:
            raise RuntimeError(f"markmap-cli exited with code {process.returncode}: {process.stderr}")
        
        # by default, output file is at the same folder as input file
        if not output_file.exists():
            raise RuntimeError(f"Output file was not created: {output_file}")
        
        return str(output_file)
        
    except Exception as e:
        raise RuntimeError(f"Error converting Markdown to mindmap: {str(e)}")

#### Tool Registration ####

# List of all tool functions to register
TOOL_FUNCTIONS = [
    convert_markdown_file_to_mindmap,
    # Add additional tool functions here
]

def register_tools(verbose=True):
    """Register all tools with the MCP server."""
    global mcp
    if mcp is None:
        raise RuntimeError("MCP instance must be initialized before registering tools")
    
    for tool_func in TOOL_FUNCTIONS:
        mcp.tool()(tool_func)
        if verbose:
            print(f"Registered tool: {tool_func.__name__}")

#### Server management functions ####

def _run_server_in_thread(port, protocol):
    """Run the MCP server in a separate thread."""
    global _server_loop, _server_running
    
    _server_loop = asyncio.new_event_loop()
    asyncio.set_event_loop(_server_loop)
    
    try:
        _server_running = True
        print(format_message('server_start', port=port))
        mcp.run(transport="streamable-http" if protocol == "http" else protocol)
    except Exception as e:
        print(format_message('server_error', error=str(e)))
    finally:
        _server_running = False

def start_server(port=None, protocol=None):
    """Start the MCP server in a separate thread."""
    global _server_thread, _server_running, _server_start_time, mcp
    
    # Use provided parameters or fall back to global defaults
    if port is None:
        port = mind_map_PORT
    if protocol is None:
        protocol = mind_map_PROTOCOL
    
    if port != mind_map_PORT:
        # Create fresh FastMCP instance with current port and protocol
        mcp = FastMCP("mind_map", port=port)
        # Register all tools with the new instance
        register_tools()
        
    try:
        # Check if server is already running
        if _server_running:
            print(format_message('server_already_running'))
            return False

        _server_thread = threading.Thread(target=_run_server_in_thread, args=(port, protocol), daemon=True)
        _server_thread.start()
        
        # Start shutdown listener in a separate daemon thread
        threading.Thread(target=shutdown_listener, args=(port,), daemon=True).start()
        
        _server_start_time = time.time()
        
        time.sleep(2)  # Wait for server to start
        if _server_running:
            print(format_message('server_started', port=port))
            return True
        else:
            print(format_message('server_start_fail'))
            return False
    except Exception as e:
        print(format_message('start_error', error=str(e)))
        return False

def stop_server(json_mode=False, port=None):
    """Stop the MCP server using multiple reliable methods."""
    global _server_thread, _server_loop, _server_running

    # Use provided port or fall back to global default
    if port is None:
        port = mind_map_PORT
    
    # First try to stop server started by this process
    if _server_running:
        try:
            _server_running = False
            
            # More aggressive shutdown
            if _server_loop and _server_loop.is_running():
                # Stop all running tasks in the loop
                for task in asyncio.all_tasks(_server_loop):
                    task.cancel()
                _server_loop.call_soon_threadsafe(_server_loop.stop)
            
            if _server_thread and _server_thread.is_alive():
                _server_thread.join(timeout=10)  # Increased timeout
                
            # Force kill thread if it's still alive
            if _server_thread and _server_thread.is_alive():
                # Reset thread reference
                _server_thread = None
        except Exception as e:
            print(format_message('stop_error', error=str(e)))
    
    # Try multiple shutdown methods for cross-process termination
    shutdown_success = False
    current_port = port
    
    # Method 1: Try graceful shutdown via control socket
    if not shutdown_success:
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(5)
                s.connect(('127.0.0.1', current_port + 1))
                s.sendall(b'SHUTDOWN')
                resp = s.recv(1024)
                if resp == b'OK':
                    shutdown_success = True
                    if not json_mode:
                        print("Server stopped successfully via shutdown listener")
        except (ConnectionRefusedError, OSError, socket.timeout):
            # Shutdown listener is not accessible, try other methods
            pass
    
    # Method 2: Try to kill process using psutil (if available)
    if not shutdown_success:
        try:
            import psutil
            killed_processes = []
            
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    # Look for Python processes running this server
                    if proc.info['name'] and 'python' in proc.info['name'].lower():
                        cmdline = proc.info['cmdline']
                        # More specific check: look for 'server.py' and server name in command line
                        if (cmdline and 
                            any('server.py' in str(arg) for arg in cmdline) and 
                            any('mind_map' in str(arg).lower() for arg in cmdline)):
                            # Check if this process is using our port
                            try:
                                for conn in proc.net_connections():
                                    if conn.laddr.port == current_port:
                                        proc.terminate()
                                        killed_processes.append(proc.info['pid'])
                                        break
                            except (psutil.AccessDenied, psutil.NoSuchProcess):
                                continue
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            
            if killed_processes:
                # Wait a moment for processes to terminate
                time.sleep(2)
                if not is_port_in_use(current_port):
                    shutdown_success = True
                    if not json_mode:
                        print(f"Server stopped successfully (killed processes: {killed_processes})")
        except ImportError:
            # psutil not available, fall back to other methods
            pass
    
    # Method 3: Try netstat + taskkill (Windows specific)
    if not shutdown_success and os.name == 'nt':
        try:
            # Find process ID using netstat
            result = subprocess.run(
                f'netstat -ano | findstr ":{current_port}"',
                capture_output=True,
                text=True,
                shell=True
            )
            
            if result.returncode == 0 and result.stdout.strip():
                lines = result.stdout.strip().split('\n')
                pids = set()
                for line in lines:
                    parts = line.split()
                    if len(parts) >= 5:
                        pids.add(parts[-1])
                
                # Kill the processes
                for pid in pids:
                    try:
                        subprocess.run(['taskkill', '/PID', pid, '/F'], 
                                     capture_output=True, check=True)
                    except:
                        continue
                
                # Wait and check if port is free
                time.sleep(2)
                if not is_port_in_use(current_port):
                    shutdown_success = True
                    if not json_mode:
                        print(f"Server stopped successfully (killed PIDs: {', '.join(pids)})")
        except Exception:
            pass
    
    # Wait for port to be released
    max_wait = 5
    wait_count = 0
    while is_port_in_use(current_port) and wait_count < max_wait:
        time.sleep(1)
        wait_count += 1
    
    # Check if server is actually stopped
    if not is_port_in_use(current_port):
        if not json_mode:
            print(format_message('server_stopped'))
        return True
    else:
        if shutdown_success:
            if not json_mode:
                print(format_message('server_stopped'))
            return True
        else:
            if not json_mode:
                print(format_message('stop_fail'))
            return False

def is_server_running():
    """Check if the server is currently running."""
    # Check both internal flag and port usage for more accurate status
    return _server_running and is_port_in_use(mind_map_PORT)

def is_port_in_use(port):
    """Check if a port is currently in use."""
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(1)  # Add timeout to avoid hanging
            result = s.connect_ex(('127.0.0.1', port))
            return result == 0
    except Exception:
        return False

def shutdown_listener(port):
    """Listen for a shutdown command on a local TCP socket."""
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        # Allow socket reuse to prevent "Address already in use" errors
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('127.0.0.1', port + 1))  # Use port + 1 for control
        sock.listen(1)
        sock.settimeout(1)  # Add timeout to make it responsive
        
        while _server_running:
            try:
                conn, addr = sock.accept()
                data = conn.recv(1024)
                if data == b'SHUTDOWN':
                    print("Shutdown command received via control socket")
                    stop_server(json_mode=False, port=port)  # Pass the port parameter
                    conn.sendall(b'OK')
                    conn.close()
                    break
                conn.close()
            except socket.timeout:
                # Continue loop to check _server_running flag
                continue
            except Exception:
                # Handle any other socket errors gracefully
                break
    except Exception as e:
        # Port might be in use or other socket error
        print(f"Shutdown listener could not start: {e}")
        # Continue without shutdown listener - other methods will still work
    finally:
        try:
            sock.close()
        except:
            pass

# Command line interface
if __name__ == "__main__":
    import json
    import argparse

    class ArgumentParserWithExceptions(argparse.ArgumentParser):
        def error(self, message):
            raise ValueError(message)
    
    def print_response(response, exit_code, json_output=False):
        """Print response and exit"""
        if json_output:
            print(json.dumps(response), flush=True)
        else:
            print(response["message"])
        sys.stdout.flush() 
        sys.exit(exit_code)
    
    # Set up argument parser
    parser = ArgumentParserWithExceptions(
        description="Create Mind Map",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python server.py start
  python server.py start --json
  python server.py stop
  python server.py status --json
  python server.py ping
  python server.py version
        """
    )
    
    parser.add_argument("command", choices=["start", "stop", "status", "ping", "version", "help"])
    parser.add_argument("--json", action="store_true")
    parser.add_argument("--timeout", type=int, default=30)
    parser.add_argument("--port", type=int)
    parser.add_argument("--protocol", choices=["sse", "stdio", "http"], help="Communication protocol")
    
    try:
        args = parser.parse_args()
        
        current_port = mind_map_PORT
        current_protocol = mind_map_PROTOCOL
        if args.port:
            current_port = args.port
            os.environ[f'MCP_MIND_MAP_PORT'] = str(current_port)
        if args.protocol:
            current_protocol = args.protocol
            os.environ[f'MCP_MIND_MAP_PROTOCOL'] = current_protocol
            
        # Initialize FastMCP with the final port and protocol values
        mcp = FastMCP("mind_map", port=current_port)
        # Register all tools with the MCP instance
        register_tools(verbose=not args.json)      
            
        def create_response(success, message, data=None, exit_code=0):
            """Create a standardized JSON response"""
            response = {
                "success": success,
                "message": message,
                "timestamp": int(time.time()),
                "port": current_port,
                "protocol": current_protocol,
            }
            if data:
                response["data"] = data
            return response, exit_code
        
        if args.command == "start":
            if start_server(current_port, current_protocol):
                response, exit_code = create_response(
                    True, 
                    format_message('server_started', port=current_port),
                    {"port": current_port},
                    exit_code=0 if _server_running else 1
                )
                
                if args.json:
                    print(json.dumps(response), flush=True)
        
                try:
                    while _server_running:
                        time.sleep(1)
                except KeyboardInterrupt:
                    print("\\nReceived interrupt signal")
                    stop_server(json_mode=args.json, port=current_port)
                    response, exit_code = create_response(True, format_message('interrupt'))
            else:
                response, exit_code = create_response(
                    False, 
                    format_message('server_start_fail'), 
                    exit_code=1
                )
                
        elif args.command == "stop":
            success = stop_server(json_mode=args.json, port=current_port)
            response, exit_code = create_response(
                success,
                format_message('stop_success' if success else 'stop_fail'),
                exit_code=0 if success else 1
            )
            
        elif args.command == "status":
            # For command line usage, check port usage since we're in a separate process
            running = is_port_in_use(current_port)
            msg_key = 'status_running' if running else 'status_stopped'
            response, exit_code = create_response(
                running,
                format_message(msg_key),
                {"status": "running" if running else "stopped", "port": current_port},
                0 if running else 1
            )
            
        elif args.command == "ping":
            # For command line usage, check port usage since we're in a separate process
            running = is_port_in_use(current_port)
            msg_key = 'ping_success' if running else 'ping_fail'
            response, exit_code = create_response(
                running,
                format_message(msg_key),
                {"status": "healthy" if running else "unhealthy", "port": current_port},
                0 if running else 1
            )
            
        elif args.command == "version":
            import platform
            version_info = {
                "version": "1.0.0",
                "python_version": platform.python_version(),
                "platform": platform.platform(),
                "port": current_port
            }
            response, exit_code = create_response(
                True, 
                format_message('version', version=version_info['version']), 
                version_info
            )
            
        elif args.command == "help":
            parser.print_help()
            sys.exit(0)
                
    except KeyboardInterrupt:
        response, exit_code = create_response(True, format_message('interrupt'))
    except Exception as e:
        response, exit_code = create_response(False, format_message('error', error=str(e)), exit_code=1)
    finally:
        if 'response' in locals():
            json_output = False
            if 'args' in locals() and hasattr(args, 'json'):
                json_output = args.json
            print_response(response, exit_code, json_output)