import os
import sys
import signal
import threading
import asyncio
import time
import socket
import subprocess
import json
import logging
from pathlib import Path
from mcp.server.fastmcp import FastMCP
from typing import List, Dict, Optional, Any
from serpapi import GoogleSearch
from rich.logging import RichHandler

# Message templates
SERVER_MESSAGES = {
    'server_start': 'google_flight MCP server starting on port {port}',
    'server_started': 'google_flight MCP server started successfully on port {port}',
    'server_stopped': 'google_flight MCP server stopped',
    'server_start_fail': 'Failed to start google_flight MCP server',
    'server_already_running': 'Server is already running',
    'server_not_running': 'Server is not running',
    'server_error': 'Server error: {error}',
    'start_error': 'Error starting server: {error}',
    'stop_error': 'Error stopping server: {error}',
    'stop_success': 'Server stopped successfully',
    'stop_fail': 'Server failed to stop',
    'status_running': 'google_flight MCP server is running',
    'status_stopped': 'google_flight MCP server is not running',
    'ping_success': 'Server is responding',
    'ping_fail': 'Server is not responding',
    'interrupt': 'Operation cancelled by user',
    'error': 'Error: {error}',
    'version': 'google_flight MCP Server v{version}',
}

def format_message(key: str, **kwargs) -> str:
    """Format a server message with given parameters."""
    template = SERVER_MESSAGES.get(key, '')
    return template.format(**kwargs) if template else ''

# Flight search specific configuration
SERP_API_KEY = os.getenv("SERP_API_KEY")

CLASS_DICT = {
    "economy": 1,
    "premium economy": 2,
    "business": 3,
    "first": 4
}

# Configure logging for flight search
def configure_logging(json_mode=False):
    """Configure logging based on output mode"""
    if json_mode:
        # In JSON mode, only log warnings and errors, redirect to stderr
        import sys
        handler = RichHandler(rich_tracebacks=True)
        handler.stream = sys.stderr
        logging.basicConfig(
            level=logging.WARNING,
            format="| %(levelname)-8s | %(name)s | %(message)s",
            datefmt="[%Y-%m-%d %H:%M:%S]",
            handlers=[handler],
            force=True
        )
    else:
        # In normal mode, use debug logging to stdout
        logging.basicConfig(
            level=logging.DEBUG,
            format="| %(levelname)-8s | %(name)s | %(message)s",
            datefmt="[%Y-%m-%d %H:%M:%S]",
            handlers=[RichHandler(rich_tracebacks=True)],
            force=True  # This overrides uvicorn & third-party loggers
        )

# Initialize with default logging (will be reconfigured based on args)
configure_logging()

logger = logging.getLogger("flight_search")
logging.getLogger("uvicorn.access").setLevel(logging.INFO)
logging.getLogger("uvicorn.error").setLevel(logging.INFO)
logging.getLogger("httpx").setLevel(logging.WARNING)

# Initialize FastMCP server
# Generated by McpServerGen.py on 2025-07-29 14:27:57
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
google_flight_PORT = int(os.getenv('MCP_GOOGLE_FLIGHT_PORT', 7901))
google_flight_PROTOCOL = os.getenv('MCP_GOOGLE_FLIGHT_PROTOCOL', 'sse')
mcp = None  # Will be initialized after command line parsing

# Global variables for server management
_server_thread = None
_server_loop = None
_server_running = False
_server_start_time = None

async def run_search(params: Dict[str, Any]):
    """
    Run SerpAPI search asynchronously.
    
    Args:
        params: Parameters for the SerpAPI search
        
    Returns:
        Search results from SerpAPI
    """
    try:
        logger.debug(f"Sending SerpAPI request with params: {json.dumps(params, indent=2)}")
        result = await asyncio.to_thread(lambda: GoogleSearch(params).get_dict())
        logger.debug(f"SerpAPI response received, keys: {list(result.keys())}")
        return result
    except Exception as e:
        logger.exception(f"SerpAPI search error: {str(e)}")
        return {"error": str(e)}

#### Server Tools ####

async def search_flights_tool(origin: str, destination: str, outbound_date: str, return_date: str = None,
                            adults: Optional[int] = 1, travel_class: Optional[str] = "economy",
                            max_num_outbound: Optional[int] = 2, max_num_inbound: Optional[int] = 2):
    """
    Search for flights using SerpAPI Google Flights.
    
    This MCP tool allows AI models to search for flight information by specifying
    departure and arrival airports and travel dates.
    
    Args:
        origin: Departure airport code (e.g., ATL, JFK)
        destination: Arrival airport code (e.g., LAX, ORD)
        outbound_date: Departure date (YYYY-MM-DD)
        return_date: Return date for round trips (YYYY-MM-DD)
        adults: Number of adult passengers (default: 1)
        travel_class: Fare class (e.g., "economy", "business", default: "economy")
        max_num_outbound: Maximum number of outbound flights to return (default: 2)
        max_num_inbound: Maximum number of inbound flights to return (default: 2)
        
    Returns:
        A list of available flights with details
    """
    logger.info(f"Searching flights: {origin} to {destination}, dates: {outbound_date} - {return_date}")
    logger.debug(f"Function called with: origin={origin}, destination={destination}, outbound_date={outbound_date}, return_date={return_date}")
    
    # Prepare search parameters
    params = {
        "api_key": SERP_API_KEY,
        "engine": "google_flights",
        "hl": "en",
        "gl": "us",
        "departure_id": origin.strip().upper(),
        "arrival_id": destination.strip().upper(),
        "outbound_date": outbound_date,
        "adults": adults,
        "travel_class": CLASS_DICT[travel_class.lower()],
        "currency": "USD"
    }
    
    # Add return date if provided (making it a round trip)
    if return_date:
        logger.debug("Round trip detected, adding return_date and setting type=1")
        params["return_date"] = return_date
        params["type"] = 1    
    else:
        params["type"] = 2            

    logger.debug("Searching outbound flights...")
    outbound_results = await run_search(params)
    
    # Check for errors
    if "error" in outbound_results:
        logger.error(f"Outbound flight search error: {outbound_results['error']}")
        return {"error": outbound_results["error"]}
    
    # Process flight results       
    best_outbound = (outbound_results.get("best_flights", []) + outbound_results.get("other_flights", []))[:max_num_outbound]
    logger.debug(f"Outbound flight search complete. Found {len(best_outbound)} best flights")
    
    if not best_outbound:
        logger.warning("No flights found for outbound")
        return []
    
    # Format flight data
    formatted_flights = []
    for i, flight in enumerate(best_outbound):
        logger.debug(f"Processing outbound flight {i+1} of {len(best_outbound)}")
        if not flight.get("flights") or len(flight["flights"]) == 0:
            logger.debug(f"Skipping outbound flight {i+1} as it has no flight segments")
            continue                    
            
        segments = []
        stop = ""
        for l, leg in enumerate(flight["flights"]):             
            infos = [f"Outbound: {leg['airline']} {leg['flight_number']}, {leg['travel_class']},"]
            departure_time_items = leg['departure_airport']['time'].split()
            departure_date = departure_time_items[0]
            departure_time = departure_time_items[1]
            arrival_time_items = leg['arrival_airport']['time'].split()
            arrival_date = arrival_time_items[0]
            arrival_time = arrival_time_items[1]
            infos.append(f"departure {leg['departure_airport']['id']} at {departure_time} on {departure_date}, arrive {leg['arrival_airport']['id']} at {arrival_time} on {arrival_date}. ")
            segments.append(" ".join(infos))        
            logger.debug(f"Outbound flight {i+1} leg {l+1}: {' '.join(infos)}")
            
        price = f"${flight.get('price')}" if flight.get("price") else "N/A"
        num_outbound_stop = len(flight["flights"]) - 1
        if num_outbound_stop == 0:
            stop = stop +  "Outbound nonstop, "  
        elif num_outbound_stop == 1:
            stop = stop + "Outbound 1 stop, "
        else:
            stop = stop + f"Outbound {num_outbound_stop} stops, "
            
        # if it is round trip, we need to get the return flights based on departure_token
        if params["type"] == 1 and "departure_token" in flight:                     
            # Execute search            
            logger.debug(f"Searching inbound flights for outbound flight {i+1}...")
            params["departure_token"] = flight["departure_token"]   
            inbound_results = await run_search(params)
            
            # Check for errors
            if "error" in inbound_results:
                logger.error(f"Inbound flight search for outbound flight {i+1} got error: {inbound_results['error']}")
                return {"error": inbound_results["error"]}
            
            # Process flight results
            logger.debug(f"================get inbound results for outbound option {i+1}=========================")        
            best_inbound = (inbound_results.get("best_flights", []) + inbound_results.get("other_flights", []))[:max_num_inbound]
            logger.debug(f"Inbound flight search for outbound flight {i+1} complete. Found {len(best_inbound)} best flights")
            
            if not best_inbound:
                logger.warning(f"No flights inbound flight for outbound flight {i+1}")
                continue
            
            for j, return_flight in enumerate(best_inbound):
                logger.debug(f"Processing inbound flight {j+1} for outbound flight {i+1} of {len(best_inbound)}")
                if not return_flight.get("flights") or len(return_flight["flights"]) == 0:
                    logger.debug(f"Skipping inbound flight {j+1} for outbound flight {i+1} as it has no flight segments")
                    continue 
                
                segments1 = segments.copy()
                num_inbound_stop = len(return_flight["flights"]) - 1
                if num_inbound_stop == 0:
                    stop1 = stop +  "Inbound nonstop."  
                elif num_inbound_stop == 1:
                    stop1 = stop + "Inbound 1 stop."
                else:
                    stop1 = stop + f"Inbound {num_inbound_stop} stops."
                    
                for l, leg in enumerate(return_flight["flights"]):                                        
                    infos = [f"Inbound: {leg['airline']} {leg['flight_number']}, {leg['travel_class']},"]
                    departure_time_items = leg['departure_airport']['time'].split()
                    departure_date = departure_time_items[0]
                    departure_time = departure_time_items[1]
                    arrival_time_items = leg['arrival_airport']['time'].split()
                    arrival_date = arrival_time_items[0]
                    arrival_time = arrival_time_items[1]
                    infos.append(f"departure {leg['departure_airport']['id']} at {departure_time} on {departure_date}, arrive {leg['arrival_airport']['id']} at {arrival_time} on {arrival_date}. ")
                    segments1.append(" ".join(infos))
                    logger.debug(f"Inbound flight option {j+1} for outbound flight {i+1}, leg {l+1}: {' '.join(infos)}") 
            
                # Add formatted flight to results
                formatted_flights.append({
                    "type": return_flight["type"],
                    "price": price,
                    "segments": "  ".join(segments1),
                    "stops": stop1                    
                })
        else:
            # One-way flight
            formatted_flights.append({
                "type": flight.get("type", "one-way"),
                "price": price,
                "segments": "  ".join(segments),
                "stops": stop.rstrip(", ")
            })
    
    logger.info(f"Returning {len(formatted_flights)} formatted flights")
    return formatted_flights

async def get_airport_info(airport_code: str) -> dict:
    """
    Get airport information by airport code.
    
    This MCP tool allows AI models to get detailed information about airports
    using their IATA codes.
    
    Args:
        airport_code: Three-letter IATA airport code (e.g., LAX, JFK, ATL)
        
    Returns:
        dict: Airport information including name, city, country
    """
    logger.info(f"Getting airport info for: {airport_code}")
    
    # Common airport codes mapping
    airports = {
        "ATL": {"name": "Hartsfield-Jackson Atlanta International Airport", "city": "Atlanta", "country": "USA", "timezone": "EST"},
        "LAX": {"name": "Los Angeles International Airport", "city": "Los Angeles", "country": "USA", "timezone": "PST"},
        "ORD": {"name": "O'Hare International Airport", "city": "Chicago", "country": "USA", "timezone": "CST"},
        "DFW": {"name": "Dallas/Fort Worth International Airport", "city": "Dallas", "country": "USA", "timezone": "CST"},
        "JFK": {"name": "John F. Kennedy International Airport", "city": "New York", "country": "USA", "timezone": "EST"},
        "LGA": {"name": "LaGuardia Airport", "city": "New York", "country": "USA", "timezone": "EST"},
        "SFO": {"name": "San Francisco International Airport", "city": "San Francisco", "country": "USA", "timezone": "PST"},
        "LAS": {"name": "McCarran International Airport", "city": "Las Vegas", "country": "USA", "timezone": "PST"},
        "SEA": {"name": "Seattle-Tacoma International Airport", "city": "Seattle", "country": "USA", "timezone": "PST"},
        "MIA": {"name": "Miami International Airport", "city": "Miami", "country": "USA", "timezone": "EST"},
        "BOS": {"name": "Logan International Airport", "city": "Boston", "country": "USA", "timezone": "EST"},
        "MSP": {"name": "Minneapolis-Saint Paul International Airport", "city": "Minneapolis", "country": "USA", "timezone": "CST"},
        "DEN": {"name": "Denver International Airport", "city": "Denver", "country": "USA", "timezone": "MST"},
        # International airports
        "LHR": {"name": "Heathrow Airport", "city": "London", "country": "UK", "timezone": "GMT"},
        "CDG": {"name": "Charles de Gaulle Airport", "city": "Paris", "country": "France", "timezone": "CET"},
        "FRA": {"name": "Frankfurt Airport", "city": "Frankfurt", "country": "Germany", "timezone": "CET"},
        "NRT": {"name": "Narita International Airport", "city": "Tokyo", "country": "Japan", "timezone": "JST"},
        "ICN": {"name": "Incheon International Airport", "city": "Seoul", "country": "South Korea", "timezone": "KST"},
        "SIN": {"name": "Singapore Changi Airport", "city": "Singapore", "country": "Singapore", "timezone": "SGT"},
        "HKG": {"name": "Hong Kong International Airport", "city": "Hong Kong", "country": "Hong Kong", "timezone": "HKT"},
        "SYD": {"name": "Sydney Kingsford Smith Airport", "city": "Sydney", "country": "Australia", "timezone": "AEST"},
        "YVR": {"name": "Vancouver International Airport", "city": "Vancouver", "country": "Canada", "timezone": "PST"},
        "YYZ": {"name": "Toronto Pearson International Airport", "city": "Toronto", "country": "Canada", "timezone": "EST"}
    }
    
    code = airport_code.upper().strip()
    if code in airports:
        return {
            "airport_code": code,
            **airports[code]
        }
    else:
        return {
            "airport_code": code,
            "error": "Airport code not found in database",
            "suggestion": "Please verify the IATA airport code is correct"
        }

async def get_travel_classes() -> dict:
    """
    Get available travel classes and their descriptions.
    
    This MCP tool provides information about different travel classes
    available for flight bookings.
    
    Returns:
        dict: Available travel classes with descriptions
    """
    logger.info("Getting travel class information")
    
    return {
        "travel_classes": {
            "economy": {
                "code": 1,
                "name": "Economy",
                "description": "Standard seating with basic amenities"
            },
            "premium economy": {
                "code": 2,
                "name": "Premium Economy", 
                "description": "Enhanced economy with more legroom and better service"
            },
            "business": {
                "code": 3,
                "name": "Business Class",
                "description": "Premium seating with lie-flat beds and premium dining"
            },
            "first": {
                "code": 4,
                "name": "First Class",
                "description": "Luxury seating with private suites and concierge service"
            }
        },
        "usage": "Use the class name (e.g., 'economy', 'business') when searching for flights"
    }

async def validate_date_format(date_string: str) -> dict:
    """
    Validate if a date string is in the correct format for flight searches.
    
    This MCP tool helps validate date formats before performing flight searches.
    
    Args:
        date_string: Date string to validate (should be YYYY-MM-DD)
        
    Returns:
        dict: Validation result with formatted date or error message
    """
    logger.info(f"Validating date format: {date_string}")
    
    try:
        from datetime import datetime
        
        # Try to parse the date
        parsed_date = datetime.strptime(date_string.strip(), '%Y-%m-%d')
        
        # Check if date is in the future
        current_date = datetime.now()
        if parsed_date.date() < current_date.date():
            return {
                "valid": False,
                "error": "Date cannot be in the past",
                "provided_date": date_string,
                "current_date": current_date.strftime('%Y-%m-%d')
            }
        
        return {
            "valid": True,
            "formatted_date": parsed_date.strftime('%Y-%m-%d'),
            "day_of_week": parsed_date.strftime('%A'),
            "provided_date": date_string
        }
        
    except ValueError as e:
        return {
            "valid": False,
            "error": "Invalid date format. Please use YYYY-MM-DD format",
            "provided_date": date_string,
            "example": "2024-12-25"
        }

#### Tool Registration ####

# List of all tool functions to register
TOOL_FUNCTIONS = [
    search_flights_tool,
    get_airport_info,
    get_travel_classes,
    validate_date_format,
    # Add additional tool functions here
]

def register_tools(verbose=True):
    """Register all tools with the MCP server."""
    global mcp
    if mcp is None:
        raise RuntimeError("MCP instance must be initialized before registering tools")
    
    for tool_func in TOOL_FUNCTIONS:
        mcp.tool()(tool_func)
        if verbose:
            print(f"Registered tool: {tool_func.__name__}")

#### Server management functions ####

def _run_server_in_thread(port, protocol):
    """Run the MCP server in a separate thread."""
    global _server_loop, _server_running
    
    _server_loop = asyncio.new_event_loop()
    asyncio.set_event_loop(_server_loop)
    
    try:
        _server_running = True
        print(format_message('server_start', port=port))
        mcp.run(transport="streamable-http" if protocol == "http" else protocol)
    except Exception as e:
        print(format_message('server_error', error=str(e)))
    finally:
        _server_running = False

def start_server(port=None, protocol=None):
    """Start the MCP server in a separate thread."""
    global _server_thread, _server_running, _server_start_time, mcp
    
    # Use provided parameters or fall back to global defaults
    if port is None:
        port = google_flight_PORT
    if protocol is None:
        protocol = google_flight_PROTOCOL
    
    if port != google_flight_PORT:
        # Create fresh FastMCP instance with current port and protocol
        mcp = FastMCP("google_flight", port=port)
        # Register all tools with the new instance
        register_tools()
        
    try:
        # Check if server is already running
        if _server_running:
            print(format_message('server_already_running'))
            return False

        _server_thread = threading.Thread(target=_run_server_in_thread, args=(port, protocol), daemon=True)
        _server_thread.start()
        
        # Start shutdown listener in a separate daemon thread
        threading.Thread(target=shutdown_listener, args=(port,), daemon=True).start()
        
        _server_start_time = time.time()
        
        time.sleep(2)  # Wait for server to start
        if _server_running:
            print(format_message('server_started', port=port))
            return True
        else:
            print(format_message('server_start_fail'))
            return False
    except Exception as e:
        print(format_message('start_error', error=str(e)))
        return False

def stop_server(json_mode=False, port=None):
    """Stop the MCP server using multiple reliable methods."""
    global _server_thread, _server_loop, _server_running

    # Use provided port or fall back to global default
    if port is None:
        port = google_flight_PORT
    
    # First try to stop server started by this process
    if _server_running:
        try:
            _server_running = False
            
            # More aggressive shutdown
            if _server_loop and _server_loop.is_running():
                # Stop all running tasks in the loop
                for task in asyncio.all_tasks(_server_loop):
                    task.cancel()
                _server_loop.call_soon_threadsafe(_server_loop.stop)
            
            if _server_thread and _server_thread.is_alive():
                _server_thread.join(timeout=10)  # Increased timeout
                
            # Force kill thread if it's still alive
            if _server_thread and _server_thread.is_alive():
                # Reset thread reference
                _server_thread = None
        except Exception as e:
            print(format_message('stop_error', error=str(e)))
    
    # Try multiple shutdown methods for cross-process termination
    shutdown_success = False
    current_port = port
    
    # Method 1: Try graceful shutdown via control socket
    if not shutdown_success:
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(5)
                s.connect(('127.0.0.1', current_port + 1))
                s.sendall(b'SHUTDOWN')
                resp = s.recv(1024)
                if resp == b'OK':
                    shutdown_success = True
                    if not json_mode:
                        print("Server stopped successfully via shutdown listener")
        except (ConnectionRefusedError, OSError, socket.timeout):
            # Shutdown listener is not accessible, try other methods
            pass
    
    # Method 2: Try to kill process using psutil (if available)
    if not shutdown_success:
        try:
            import psutil
            killed_processes = []
            
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    # Look for Python processes running this server
                    if proc.info['name'] and 'python' in proc.info['name'].lower():
                        cmdline = proc.info['cmdline']
                        # More specific check: look for 'server.py' and server name in command line
                        if (cmdline and 
                            any('server.py' in str(arg) for arg in cmdline) and 
                            any('google_flight' in str(arg).lower() for arg in cmdline)):
                            # Check if this process is using our port
                            try:
                                for conn in proc.net_connections():
                                    if conn.laddr.port == current_port:
                                        proc.terminate()
                                        killed_processes.append(proc.info['pid'])
                                        break
                            except (psutil.AccessDenied, psutil.NoSuchProcess):
                                continue
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            
            if killed_processes:
                # Wait a moment for processes to terminate
                time.sleep(2)
                if not is_port_in_use(current_port):
                    shutdown_success = True
                    if not json_mode:
                        print(f"Server stopped successfully (killed processes: {killed_processes})")
        except ImportError:
            # psutil not available, fall back to other methods
            pass
    
    # Method 3: Try netstat + taskkill (Windows specific)
    if not shutdown_success and os.name == 'nt':
        try:
            # Find process ID using netstat
            result = subprocess.run(
                f'netstat -ano | findstr ":{current_port}"',
                capture_output=True,
                text=True,
                shell=True
            )
            
            if result.returncode == 0 and result.stdout.strip():
                lines = result.stdout.strip().split('\n')
                pids = set()
                for line in lines:
                    parts = line.split()
                    if len(parts) >= 5:
                        pids.add(parts[-1])
                
                # Kill the processes
                for pid in pids:
                    try:
                        subprocess.run(['taskkill', '/PID', pid, '/F'], 
                                     capture_output=True, check=True)
                    except:
                        continue
                
                # Wait and check if port is free
                time.sleep(2)
                if not is_port_in_use(current_port):
                    shutdown_success = True
                    if not json_mode:
                        print(f"Server stopped successfully (killed PIDs: {', '.join(pids)})")
        except Exception:
            pass
    
    # Wait for port to be released
    max_wait = 5
    wait_count = 0
    while is_port_in_use(current_port) and wait_count < max_wait:
        time.sleep(1)
        wait_count += 1
    
    # Check if server is actually stopped
    if not is_port_in_use(current_port):
        if not json_mode:
            print(format_message('server_stopped'))
        return True
    else:
        if shutdown_success:
            if not json_mode:
                print(format_message('server_stopped'))
            return True
        else:
            if not json_mode:
                print(format_message('stop_fail'))
            return False

def is_server_running():
    """Check if the server is currently running."""
    # Check both internal flag and port usage for more accurate status
    return _server_running and is_port_in_use(google_flight_PORT)

def is_port_in_use(port):
    """Check if a port is currently in use."""
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(1)  # Add timeout to avoid hanging
            result = s.connect_ex(('127.0.0.1', port))
            return result == 0
    except Exception:
        return False

def shutdown_listener(port):
    """Listen for a shutdown command on a local TCP socket."""
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        # Allow socket reuse to prevent "Address already in use" errors
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('127.0.0.1', port + 1))  # Use port + 1 for control
        sock.listen(1)
        sock.settimeout(1)  # Add timeout to make it responsive
        
        while _server_running:
            try:
                conn, addr = sock.accept()
                data = conn.recv(1024)
                if data == b'SHUTDOWN':
                    print("Shutdown command received via control socket")
                    stop_server(json_mode=False, port=port)  # Pass the port parameter
                    conn.sendall(b'OK')
                    conn.close()
                    break
                conn.close()
            except socket.timeout:
                # Continue loop to check _server_running flag
                continue
            except Exception:
                # Handle any other socket errors gracefully
                break
    except Exception as e:
        # Port might be in use or other socket error
        print(f"Shutdown listener could not start: {e}")
        # Continue without shutdown listener - other methods will still work
    finally:
        try:
            sock.close()
        except:
            pass

# Command line interface
if __name__ == "__main__":
    import json
    import argparse

    class ArgumentParserWithExceptions(argparse.ArgumentParser):
        def error(self, message):
            raise ValueError(message)
    
    def print_response(response, exit_code, json_output=False):
        """Print response and exit"""
        if json_output:
            print(json.dumps(response), flush=True)
        else:
            print(response["message"])
        sys.stdout.flush() 
        sys.exit(exit_code)
    
    # Set up argument parser
    parser = ArgumentParserWithExceptions(
        description="Search goolge flight",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python server.py start
  python server.py start --json
  python server.py stop
  python server.py status --json
  python server.py ping
  python server.py version
        """
    )
    
    parser.add_argument("command", choices=["start", "stop", "status", "ping", "version", "help"])
    parser.add_argument("--json", action="store_true")
    parser.add_argument("--timeout", type=int, default=30)
    parser.add_argument("--port", type=int)
    parser.add_argument("--protocol", choices=["sse", "stdio", "http"], help="Communication protocol")
    
    try:
        args = parser.parse_args()
        
        # Configure logging based on output mode
        configure_logging(json_mode=args.json)
        
        current_port = google_flight_PORT
        current_protocol = google_flight_PROTOCOL
        if args.port:
            current_port = args.port
            os.environ[f'MCP_GOOGLE_FLIGHT_PORT'] = str(current_port)
        if args.protocol:
            current_protocol = args.protocol
            os.environ[f'MCP_GOOGLE_FLIGHT_PROTOCOL'] = current_protocol
            
        # Initialize FastMCP with the final port and protocol values
        mcp = FastMCP("google_flight", port=current_port)
        # Register all tools with the MCP instance
        register_tools(verbose=not args.json)      
            
        def create_response(success, message, data=None, exit_code=0):
            """Create a standardized JSON response"""
            response = {
                "success": success,
                "message": message,
                "timestamp": int(time.time()),
                "port": current_port,
                "protocol": current_protocol,
            }
            if data:
                response["data"] = data
            return response, exit_code
        
        if args.command == "start":
            if start_server(current_port, current_protocol):
                response, exit_code = create_response(
                    True, 
                    format_message('server_started', port=current_port),
                    {"port": current_port},
                    exit_code=0 if _server_running else 1
                )
                
                if args.json:
                    print(json.dumps(response), flush=True)
        
                try:
                    while _server_running:
                        time.sleep(1)
                except KeyboardInterrupt:
                    print("\\nReceived interrupt signal")
                    stop_server(json_mode=args.json, port=current_port)
                    response, exit_code = create_response(True, format_message('interrupt'))
            else:
                response, exit_code = create_response(
                    False, 
                    format_message('server_start_fail'), 
                    exit_code=1
                )
                
        elif args.command == "stop":
            success = stop_server(json_mode=args.json, port=current_port)
            response, exit_code = create_response(
                success,
                format_message('stop_success' if success else 'stop_fail'),
                exit_code=0 if success else 1
            )
            
        elif args.command == "status":
            # For command line usage, check port usage since we're in a separate process
            running = is_port_in_use(current_port)
            msg_key = 'status_running' if running else 'status_stopped'
            response, exit_code = create_response(
                running,
                format_message(msg_key),
                {"status": "running" if running else "stopped", "port": current_port},
                0 if running else 1
            )
            
        elif args.command == "ping":
            # For command line usage, check port usage since we're in a separate process
            running = is_port_in_use(current_port)
            msg_key = 'ping_success' if running else 'ping_fail'
            response, exit_code = create_response(
                running,
                format_message(msg_key),
                {"status": "healthy" if running else "unhealthy", "port": current_port},
                0 if running else 1
            )
            
        elif args.command == "version":
            import platform
            version_info = {
                "version": "1.0.0",
                "python_version": platform.python_version(),
                "platform": platform.platform(),
                "port": current_port
            }
            response, exit_code = create_response(
                True, 
                format_message('version', version=version_info['version']), 
                version_info
            )
            
        elif args.command == "help":
            parser.print_help()
            sys.exit(0)
                
    except KeyboardInterrupt:
        response, exit_code = create_response(True, format_message('interrupt'))
    except Exception as e:
        response, exit_code = create_response(False, format_message('error', error=str(e)), exit_code=1)
    finally:
        if 'response' in locals():
            json_output = False
            if 'args' in locals() and hasattr(args, 'json'):
                json_output = args.json
            print_response(response, exit_code, json_output)