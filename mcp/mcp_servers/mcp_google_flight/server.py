import os
import sys
import signal
import threading
import asyncio
import time
import socket
import subprocess
import json
import logging
from pathlib import Path
from mcp.server.fastmcp import FastMCP
from typing import List, Dict, Optional, Any
from serpapi import GoogleSearch
from rich.logging import RichHandler

# Message templates
SERVER_MESSAGES = {
    'server_start': 'google_flight MCP server starting' + (' on port {port}' if 'http' != 'stdio' else ''),
    'server_started': 'google_flight MCP server started successfully' + (' on port {port}' if 'http' != 'stdio' else ''),
    'server_stopped': 'google_flight MCP server stopped',
    'server_start_fail': 'Failed to start google_flight MCP server',
    'server_already_running': 'Server is already running',
    'server_not_running': 'Server is not running',
    'server_error': 'Server error: {error}',
    'start_error': 'Error starting server: {error}',
    'stop_error': 'Error stopping server: {error}',
    'stop_success': 'Server stopped successfully',
    'stop_fail': 'Server failed to stop',
    'status_running': 'google_flight MCP server is running',
    'status_stopped': 'google_flight MCP server is not running',
    'ping_success': 'Server is responding',
    'ping_fail': 'Server is not responding',
    'interrupt': 'Operation cancelled by user',
    'error': 'Error: {error}',
    'version': 'google_flight MCP Server v{version}',
}

def format_message(key: str, **kwargs) -> str:
    """Format a server message with given parameters."""
    template = SERVER_MESSAGES.get(key, '')
    return template.format(**kwargs) if template else ''

def create_response(success, message, data=None, exit_code=0, current_port=None, current_protocol=None):
    """Create a standardized JSON response"""
    response = {
        "success": success,
        "message": message,
        "timestamp": int(time.time()),
        "protocol": current_protocol or google_flight_PROTOCOL,
    }
    if current_protocol != 'stdio' and current_port is not None:
        response["port"] = current_port
    if data:
        response["data"] = data
    return response, exit_code

# Flight search specific configuration
SERP_API_KEY = os.getenv("SERP_API_KEY")

CLASS_DICT = {
    "economy": 1,
    "premium economy": 2,
    "business": 3,
    "first": 4
}

# Configure logging for flight search
def configure_logging(json_mode=False):
    """Configure logging based on output mode"""
    if json_mode:
        # In JSON mode, only log warnings and errors, redirect to stderr
        import sys
        handler = RichHandler(rich_tracebacks=True)
        handler.stream = sys.stderr
        logging.basicConfig(
            level=logging.WARNING,
            format="| %(levelname)-8s | %(name)s | %(message)s",
            datefmt="[%Y-%m-%d %H:%M:%S]",
            handlers=[handler],
            force=True
        )
    else:
        # In normal mode, use debug logging to stdout
        logging.basicConfig(
            level=logging.DEBUG,
            format="| %(levelname)-8s | %(name)s | %(message)s",
            datefmt="[%Y-%m-%d %H:%M:%S]",
            handlers=[RichHandler(rich_tracebacks=True)],
            force=True  # This overrides uvicorn & third-party loggers
        )

# Initialize with default logging (will be reconfigured based on args)
configure_logging()

logger = logging.getLogger("flight_search")
logging.getLogger("uvicorn.access").setLevel(logging.INFO)
logging.getLogger("uvicorn.error").setLevel(logging.INFO)
logging.getLogger("httpx").setLevel(logging.WARNING)

# Initialize FastMCP server
# Generated by McpServerGen.py on 2025-09-02 11:09:43
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
google_flight_PORT = int(os.getenv('MCP_GOOGLE_FLIGHT_PORT', 7901)) if 'http' != 'stdio' else None
google_flight_PROTOCOL = os.getenv('MCP_GOOGLE_FLIGHT_PROTOCOL', 'http')
mcp = None  # Will be initialized after command line parsing

# Global variables for server management
_server_thread = None
_server_loop = None
_server_running = False
_server_start_time = None

async def run_search(params: Dict[str, Any]):
    """
    Run SerpAPI search asynchronously.
    
    Args:
        params: Parameters for the SerpAPI search
        
    Returns:
        Search results from SerpAPI
    """
    try:
        logger.debug(f"Sending SerpAPI request with params: {json.dumps(params, indent=2)}")
        result = await asyncio.to_thread(lambda: GoogleSearch(params).get_dict())
        logger.debug(f"SerpAPI response received, keys: {list(result.keys())}")
        return result
    except Exception as e:
        logger.exception(f"SerpAPI search error: {str(e)}")
        return {"error": str(e)}

#### Server Tools ####

async def search_flights_tool(origin: str, destination: str, outbound_date: str, return_date: str = None,
                            adults: Optional[int] = 1, travel_class: Optional[str] = "economy",
                            max_num_outbound: Optional[int] = 2, max_num_inbound: Optional[int] = 2):
    """
    Search for flights using SerpAPI Google Flights.
    
    This MCP tool allows AI models to search for flight information by specifying
    departure and arrival airports and travel dates.
    
    Args:
        origin: Departure airport code (e.g., ATL, JFK)
        destination: Arrival airport code (e.g., LAX, ORD)
        outbound_date: Departure date (YYYY-MM-DD)
        return_date: Return date for round trips (YYYY-MM-DD)
        adults: Number of adult passengers (default: 1)
        travel_class: Fare class (e.g., "economy", "business", default: "economy")
        max_num_outbound: Maximum number of outbound flights to return (default: 2)
        max_num_inbound: Maximum number of inbound flights to return (default: 2)
        
    Returns:
        A list of available flights with details
    """
    logger.info(f"Searching flights: {origin} to {destination}, dates: {outbound_date} - {return_date}")
    logger.debug(f"Function called with: origin={origin}, destination={destination}, outbound_date={outbound_date}, return_date={return_date}")
    
    # Prepare search parameters
    params = {
        "api_key": SERP_API_KEY,
        "engine": "google_flights",
        "hl": "en",
        "gl": "us",
        "departure_id": origin.strip().upper(),
        "arrival_id": destination.strip().upper(),
        "outbound_date": outbound_date,
        "adults": adults,
        "travel_class": CLASS_DICT[travel_class.lower()],
        "currency": "USD"
    }
    
    # Add return date if provided (making it a round trip)
    if return_date:
        logger.debug("Round trip detected, adding return_date and setting type=1")
        params["return_date"] = return_date
        params["type"] = 1    
    else:
        params["type"] = 2            

    logger.debug("Searching outbound flights...")
    outbound_results = await run_search(params)
    
    # Check for errors
    if "error" in outbound_results:
        logger.error(f"Outbound flight search error: {outbound_results['error']}")
        return {"error": outbound_results["error"]}
    
    # Process flight results       
    best_outbound = (outbound_results.get("best_flights", []) + outbound_results.get("other_flights", []))[:max_num_outbound]
    logger.debug(f"Outbound flight search complete. Found {len(best_outbound)} best flights")
    
    if not best_outbound:
        logger.warning("No flights found for outbound")
        return []
    
    # Format flight data
    formatted_flights = []
    for i, flight in enumerate(best_outbound):
        logger.debug(f"Processing outbound flight {i+1} of {len(best_outbound)}")
        if not flight.get("flights") or len(flight["flights"]) == 0:
            logger.debug(f"Skipping outbound flight {i+1} as it has no flight segments")
            continue                    
            
        segments = []
        stop = ""
        for l, leg in enumerate(flight["flights"]):             
            infos = [f"Outbound: {leg['airline']} {leg['flight_number']}, {leg['travel_class']},"]
            departure_time_items = leg['departure_airport']['time'].split()
            departure_date = departure_time_items[0]
            departure_time = departure_time_items[1]
            arrival_time_items = leg['arrival_airport']['time'].split()
            arrival_date = arrival_time_items[0]
            arrival_time = arrival_time_items[1]
            infos.append(f"departure {leg['departure_airport']['id']} at {departure_time} on {departure_date}, arrive {leg['arrival_airport']['id']} at {arrival_time} on {arrival_date}. ")
            segments.append(" ".join(infos))        
            logger.debug(f"Outbound flight {i+1} leg {l+1}: {' '.join(infos)}")
            
        price = f"${flight.get('price')}" if flight.get("price") else "N/A"
        num_outbound_stop = len(flight["flights"]) - 1
        if num_outbound_stop == 0:
            stop = stop +  "Outbound nonstop, "  
        elif num_outbound_stop == 1:
            stop = stop + "Outbound 1 stop, "
        else:
            stop = stop + f"Outbound {num_outbound_stop} stops, "
            
        # if it is round trip, we need to get the return flights based on departure_token
        if params["type"] == 1 and "departure_token" in flight:                     
            # Execute search            
            logger.debug(f"Searching inbound flights for outbound flight {i+1}...")
            params["departure_token"] = flight["departure_token"]   
            inbound_results = await run_search(params)
            
            # Check for errors
            if "error" in inbound_results:
                logger.error(f"Inbound flight search for outbound flight {i+1} got error: {inbound_results['error']}")
                return {"error": inbound_results["error"]}
            
            # Process flight results
            logger.debug(f"================get inbound results for outbound option {i+1}=========================")        
            best_inbound = (inbound_results.get("best_flights", []) + inbound_results.get("other_flights", []))[:max_num_inbound]
            logger.debug(f"Inbound flight search for outbound flight {i+1} complete. Found {len(best_inbound)} best flights")
            
            if not best_inbound:
                logger.warning(f"No flights inbound flight for outbound flight {i+1}")
                continue
            
            for j, return_flight in enumerate(best_inbound):
                logger.debug(f"Processing inbound flight {j+1} for outbound flight {i+1} of {len(best_inbound)}")
                if not return_flight.get("flights") or len(return_flight["flights"]) == 0:
                    logger.debug(f"Skipping inbound flight {j+1} for outbound flight {i+1} as it has no flight segments")
                    continue 
                
                segments1 = segments.copy()
                num_inbound_stop = len(return_flight["flights"]) - 1
                if num_inbound_stop == 0:
                    stop1 = stop +  "Inbound nonstop."  
                elif num_inbound_stop == 1:
                    stop1 = stop + "Inbound 1 stop."
                else:
                    stop1 = stop + f"Inbound {num_inbound_stop} stops."
                    
                for l, leg in enumerate(return_flight["flights"]):                                        
                    infos = [f"Inbound: {leg['airline']} {leg['flight_number']}, {leg['travel_class']},"]
                    departure_time_items = leg['departure_airport']['time'].split()
                    departure_date = departure_time_items[0]
                    departure_time = departure_time_items[1]
                    arrival_time_items = leg['arrival_airport']['time'].split()
                    arrival_date = arrival_time_items[0]
                    arrival_time = arrival_time_items[1]
                    infos.append(f"departure {leg['departure_airport']['id']} at {departure_time} on {departure_date}, arrive {leg['arrival_airport']['id']} at {arrival_time} on {arrival_date}. ")
                    segments1.append(" ".join(infos))
                    logger.debug(f"Inbound flight option {j+1} for outbound flight {i+1}, leg {l+1}: {' '.join(infos)}") 
            
                # Add formatted flight to results
                formatted_flights.append({
                    "type": return_flight["type"],
                    "price": price,
                    "segments": "  ".join(segments1),
                    "stops": stop1                    
                })
        else:
            # One-way flight
            formatted_flights.append({
                "type": flight.get("type", "one-way"),
                "price": price,
                "segments": "  ".join(segments),
                "stops": stop.rstrip(", ")
            })
    
    logger.info(f"Returning {len(formatted_flights)} formatted flights")
    return formatted_flights

async def get_airport_info(airport_code: str) -> dict:
    """
    Get airport information by airport code.
    
    This MCP tool allows AI models to get detailed information about airports
    using their IATA codes.
    
    Args:
        airport_code: Three-letter IATA airport code (e.g., LAX, JFK, ATL)
        
    Returns:
        dict: Airport information including name, city, country
    """
    logger.info(f"Getting airport info for: {airport_code}")
    
    # Common airport codes mapping
    airports = {
        "ATL": {"name": "Hartsfield-Jackson Atlanta International Airport", "city": "Atlanta", "country": "USA", "timezone": "EST"},
        "LAX": {"name": "Los Angeles International Airport", "city": "Los Angeles", "country": "USA", "timezone": "PST"},
        "ORD": {"name": "O'Hare International Airport", "city": "Chicago", "country": "USA", "timezone": "CST"},
        "DFW": {"name": "Dallas/Fort Worth International Airport", "city": "Dallas", "country": "USA", "timezone": "CST"},
        "JFK": {"name": "John F. Kennedy International Airport", "city": "New York", "country": "USA", "timezone": "EST"},
        "LGA": {"name": "LaGuardia Airport", "city": "New York", "country": "USA", "timezone": "EST"},
        "SFO": {"name": "San Francisco International Airport", "city": "San Francisco", "country": "USA", "timezone": "PST"},
        "LAS": {"name": "McCarran International Airport", "city": "Las Vegas", "country": "USA", "timezone": "PST"},
        "SEA": {"name": "Seattle-Tacoma International Airport", "city": "Seattle", "country": "USA", "timezone": "PST"},
        "MIA": {"name": "Miami International Airport", "city": "Miami", "country": "USA", "timezone": "EST"},
        "BOS": {"name": "Logan International Airport", "city": "Boston", "country": "USA", "timezone": "EST"},
        "MSP": {"name": "Minneapolis-Saint Paul International Airport", "city": "Minneapolis", "country": "USA", "timezone": "CST"},
        "DEN": {"name": "Denver International Airport", "city": "Denver", "country": "USA", "timezone": "MST"},
        # International airports
        "LHR": {"name": "Heathrow Airport", "city": "London", "country": "UK", "timezone": "GMT"},
        "CDG": {"name": "Charles de Gaulle Airport", "city": "Paris", "country": "France", "timezone": "CET"},
        "FRA": {"name": "Frankfurt Airport", "city": "Frankfurt", "country": "Germany", "timezone": "CET"},
        "NRT": {"name": "Narita International Airport", "city": "Tokyo", "country": "Japan", "timezone": "JST"},
        "ICN": {"name": "Incheon International Airport", "city": "Seoul", "country": "South Korea", "timezone": "KST"},
        "SIN": {"name": "Singapore Changi Airport", "city": "Singapore", "country": "Singapore", "timezone": "SGT"},
        "HKG": {"name": "Hong Kong International Airport", "city": "Hong Kong", "country": "Hong Kong", "timezone": "HKT"},
        "SYD": {"name": "Sydney Kingsford Smith Airport", "city": "Sydney", "country": "Australia", "timezone": "AEST"},
        "YVR": {"name": "Vancouver International Airport", "city": "Vancouver", "country": "Canada", "timezone": "PST"},
        "YYZ": {"name": "Toronto Pearson International Airport", "city": "Toronto", "country": "Canada", "timezone": "EST"}
    }
    
    code = airport_code.upper().strip()
    if code in airports:
        return {
            "airport_code": code,
            **airports[code]
        }
    else:
        return {
            "airport_code": code,
            "error": "Airport code not found in database",
            "suggestion": "Please verify the IATA airport code is correct"
        }

async def get_travel_classes() -> dict:
    """
    Get available travel classes and their descriptions.
    
    This MCP tool provides information about different travel classes
    available for flight bookings.
    
    Returns:
        dict: Available travel classes with descriptions
    """
    logger.info("Getting travel class information")
    
    return {
        "travel_classes": {
            "economy": {
                "code": 1,
                "name": "Economy",
                "description": "Standard seating with basic amenities"
            },
            "premium economy": {
                "code": 2,
                "name": "Premium Economy", 
                "description": "Enhanced economy with more legroom and better service"
            },
            "business": {
                "code": 3,
                "name": "Business Class",
                "description": "Premium seating with lie-flat beds and premium dining"
            },
            "first": {
                "code": 4,
                "name": "First Class",
                "description": "Luxury seating with private suites and concierge service"
            }
        },
        "usage": "Use the class name (e.g., 'economy', 'business') when searching for flights"
    }

async def validate_date_format(date_string: str) -> dict:
    """
    Validate if a date string is in the correct format for flight searches.
    
    This MCP tool helps validate date formats before performing flight searches.
    
    Args:
        date_string: Date string to validate (should be YYYY-MM-DD)
        
    Returns:
        dict: Validation result with formatted date or error message
    """
    logger.info(f"Validating date format: {date_string}")
    
    try:
        from datetime import datetime
        
        # Try to parse the date
        parsed_date = datetime.strptime(date_string.strip(), '%Y-%m-%d')
        
        # Check if date is in the future
        current_date = datetime.now()
        if parsed_date.date() < current_date.date():
            return {
                "valid": False,
                "error": "Date cannot be in the past",
                "provided_date": date_string,
                "current_date": current_date.strftime('%Y-%m-%d')
            }
        
        return {
            "valid": True,
            "formatted_date": parsed_date.strftime('%Y-%m-%d'),
            "day_of_week": parsed_date.strftime('%A'),
            "provided_date": date_string
        }
        
    except ValueError as e:
        return {
            "valid": False,
            "error": "Invalid date format. Please use YYYY-MM-DD format",
            "provided_date": date_string,
            "example": "2024-12-25"
        }

#### Tool Registration ####

# List of all tool functions to register
TOOL_FUNCTIONS = [
    search_flights_tool,
    get_airport_info,
    get_travel_classes,
    validate_date_format,
    # Add additional tool functions here
]

def register_tools(verbose=True):
    """Register all tools with the MCP server."""
    global mcp
    if mcp is None:
        raise RuntimeError("MCP instance must be initialized before registering tools")
    
    for tool_func in TOOL_FUNCTIONS:
        mcp.tool()(tool_func)
        if verbose:
            print(f"Registered tool: {tool_func.__name__}")

#### Server management functions ####

def _run_server_in_thread(port, protocol):
    """Run the MCP server in a separate thread."""
    global _server_loop, _server_running
    
    _server_loop = asyncio.new_event_loop()
    asyncio.set_event_loop(_server_loop)
    
    try:
        _server_running = True
        if protocol == 'stdio':
            print(format_message('server_start'))
        else:
            print(format_message('server_start', port=port))
        mcp.run(transport="streamable-http" if protocol == "http" else protocol)
    except Exception as e:
        print(format_message('server_error', error=str(e)))
    finally:
        _server_running = False

def start_server(port=None, protocol=None):
    """Start the MCP server in a separate thread."""
    global _server_thread, _server_running, _server_start_time, mcp
    
    # Use provided parameters or fall back to global defaults
    if port is None:
        port = google_flight_PORT
    if protocol is None:
        protocol = google_flight_PROTOCOL
    
    # For stdio protocol, we don't need a port
    if protocol == 'stdio':
        port = None
    
    if (protocol == 'stdio' and mcp is None) or (protocol != 'stdio' and port != google_flight_PORT):
        # Create fresh FastMCP instance with current port and protocol
        if protocol == 'stdio':
            mcp = FastMCP("google_flight")
        else:
            mcp = FastMCP("google_flight", port=port)
        # Register all tools with the new instance
        register_tools()
        
    try:
        # Check if server is already running
        if _server_running:
            print(format_message('server_already_running'))
            return False

        _server_thread = threading.Thread(target=_run_server_in_thread, args=(port, protocol), daemon=True)
        _server_thread.start()
        
        # Start shutdown listener in a separate daemon thread (only for non-stdio protocols)
        if protocol != 'stdio' and port is not None:
            threading.Thread(target=shutdown_listener, args=(port,), daemon=True).start()
        
        _server_start_time = time.time()
        
        time.sleep(2)  # Wait for server to start
        if _server_running:
            if protocol == 'stdio':
                print(format_message('server_started'))
            else:
                print(format_message('server_started', port=port))
            return True
        else:
            print(format_message('server_start_fail'))
            return False
    except Exception as e:
        print(format_message('start_error', error=str(e)))
        return False

def stop_server(json_mode=False, port=None):
    """Stop the MCP server using multiple reliable methods."""
    global _server_thread, _server_loop, _server_running

    # Use provided port or fall back to global default
    if port is None:
        port = google_flight_PORT
    
    # For stdio protocol, port is None
    if google_flight_PROTOCOL == 'stdio':
        port = None
    
    # First try to stop server started by this process
    if _server_running:
        try:
            _server_running = False
            
            # More aggressive shutdown
            if _server_loop and _server_loop.is_running():
                # Stop all running tasks in the loop
                for task in asyncio.all_tasks(_server_loop):
                    task.cancel()
                _server_loop.call_soon_threadsafe(_server_loop.stop)
            
            if _server_thread and _server_thread.is_alive():
                _server_thread.join(timeout=10)  # Increased timeout
                
            # Force kill thread if it's still alive
            if _server_thread and _server_thread.is_alive():
                # Reset thread reference
                _server_thread = None
        except Exception as e:
            print(format_message('stop_error', error=str(e)))
    
    # Try multiple shutdown methods for cross-process termination (skip for stdio)
    shutdown_success = False
    current_port = port
    
    # Skip port-based shutdown methods for stdio protocol
    if current_port is not None:
        # Method 1: Try graceful shutdown via control socket
        if not shutdown_success:
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(5)
                    s.connect(('127.0.0.1', current_port + 1))
                    s.sendall(b'SHUTDOWN')
                    resp = s.recv(1024)
                    if resp == b'OK':
                        shutdown_success = True
                        if not json_mode:
                            print("Server stopped successfully via shutdown listener")
            except (ConnectionRefusedError, OSError, socket.timeout):
                # Shutdown listener is not accessible, try other methods
                pass
    
        # Method 2: Try to kill process using psutil (if available)
        if not shutdown_success and current_port is not None:
            try:
                import psutil
                killed_processes = []
                
                for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                    try:
                        # Look for Python processes running this server
                        if proc.info['name'] and 'python' in proc.info['name'].lower():
                            cmdline = proc.info['cmdline']
                            # More specific check: look for 'server.py' and server name in command line
                            if (cmdline and 
                                any('server.py' in str(arg) for arg in cmdline) and 
                                any('google_flight' in str(arg).lower() for arg in cmdline)):
                                # Check if this process is using our port
                                try:
                                    for conn in proc.net_connections():
                                        if conn.laddr.port == current_port:
                                            proc.terminate()
                                            killed_processes.append(proc.info['pid'])
                                            break
                                except (psutil.AccessDenied, psutil.NoSuchProcess):
                                    continue
                    except (psutil.NoSuchProcess, psutil.AccessDenied):
                        continue
                
                if killed_processes:
                    # Wait a moment for processes to terminate
                    time.sleep(2)
                    if not is_port_in_use(current_port):
                        shutdown_success = True
                        if not json_mode:
                            print(f"Server stopped successfully (killed processes: {killed_processes})")
            except ImportError:
                # psutil not available, fall back to other methods
                pass
        
        # Method 3: Try netstat + taskkill (Windows specific)
        if not shutdown_success and current_port is not None and os.name == 'nt':
            try:
                # Find process ID using netstat
                result = subprocess.run(
                    f'netstat -ano | findstr ":{current_port}"',
                    capture_output=True,
                    text=True,
                    shell=True
                )
                
                if result.returncode == 0 and result.stdout.strip():
                    lines = result.stdout.strip().split('\n')
                    pids = set()
                    for line in lines:
                        parts = line.split()
                        if len(parts) >= 5:
                            pids.add(parts[-1])
                    
                    # Kill the processes
                    for pid in pids:
                        try:
                            subprocess.run(['taskkill', '/PID', pid, '/F'], 
                                         capture_output=True, check=True)
                        except:
                            continue
                    
                    # Wait and check if port is free
                    time.sleep(2)
                    if not is_port_in_use(current_port):
                        shutdown_success = True
                        if not json_mode:
                            print(f"Server stopped successfully (killed PIDs: {', '.join(pids)})")
            except Exception:
                pass
    
    # For protocols with ports, wait for port to be released
    if current_port is not None:
        max_wait = 5
        wait_count = 0
        while is_port_in_use(current_port) and wait_count < max_wait:
            time.sleep(1)
            wait_count += 1
    
    # Check if server is actually stopped
    if current_port is None:  # stdio protocol
        # For stdio, just check if the internal process stopped
        if not _server_running:
            if not json_mode:
                print(format_message('server_stopped'))
            return True
        else:
            if not json_mode:
                print(format_message('stop_fail'))
            return False
    elif not is_port_in_use(current_port):  # port-based protocols
        if not json_mode:
            print(format_message('server_stopped'))
        return True
    else:
        if shutdown_success:
            if not json_mode:
                print(format_message('server_stopped'))
            return True
        else:
            if not json_mode:
                print(format_message('stop_fail'))
            return False

def is_server_running():
    """Check if the server is currently running."""
    # For stdio protocol, only check the internal flag since there's no port
    if google_flight_PROTOCOL == 'stdio':
        return _server_running
    # For other protocols, check both internal flag and port usage for more accurate status
    return _server_running and is_port_in_use(google_flight_PORT)

def is_port_in_use(port):
    """Check if a port is currently in use."""
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(1)  # Add timeout to avoid hanging
            result = s.connect_ex(('127.0.0.1', port))
            return result == 0
    except Exception:
        return False

def shutdown_listener(port):
    """Listen for a shutdown command on a local TCP socket."""
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        # Allow socket reuse to prevent "Address already in use" errors
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('127.0.0.1', port + 1))  # Use port + 1 for control
        sock.listen(1)
        sock.settimeout(1)  # Add timeout to make it responsive
        
        while _server_running:
            try:
                conn, addr = sock.accept()
                data = conn.recv(1024)
                if data == b'SHUTDOWN':
                    print("Shutdown command received via control socket")
                    stop_server(json_mode=False, port=port)  # Pass the port parameter
                    conn.sendall(b'OK')
                    conn.close()
                    break
                conn.close()
            except socket.timeout:
                # Continue loop to check _server_running flag
                continue
            except Exception:
                # Handle any other socket errors gracefully
                break
    except Exception as e:
        # Port might be in use or other socket error
        print(f"Shutdown listener could not start: {e}")
        # Continue without shutdown listener - other methods will still work
    finally:
        try:
            sock.close()
        except:
            pass

# Command line interface
if __name__ == "__main__":
    import json
    import argparse

    class ArgumentParserWithExceptions(argparse.ArgumentParser):
        def error(self, message):
            raise ValueError(message)
    
    def print_response(response, exit_code, json_output=False):
        """Print response and exit"""
        if json_output:
            print(json.dumps(response), flush=True)
        else:
            print(response["message"])
        sys.stdout.flush() 
        sys.exit(exit_code)
    
    # Set up argument parser
    parser = ArgumentParserWithExceptions(
        description="Search google flights",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python server.py start
  python server.py start --json
  python server.py stop
  python server.py status --json
  python server.py ping
  python server.py version
        """
    )
    
    parser.add_argument("command", choices=["start", "stop", "status", "ping", "version", "help"])
    parser.add_argument("--json", action="store_true")
    parser.add_argument("--timeout", type=int, default=30)
    parser.add_argument("--port", type=int)
    parser.add_argument("--protocol", choices=["sse", "stdio", "http"], help="Communication protocol")
    
    try:
        args = parser.parse_args()
        
        # Configure logging based on output mode
        configure_logging(json_mode=args.json)
        
        current_port = google_flight_PORT
        current_protocol = google_flight_PROTOCOL
        if args.port:
            current_port = args.port
            os.environ[f'MCP_GOOGLE_FLIGHT_PORT'] = str(current_port)
        if args.protocol:
            current_protocol = args.protocol
            os.environ[f'MCP_GOOGLE_FLIGHT_PROTOCOL'] = current_protocol
        
        # For stdio protocol, ignore port setting
        if current_protocol == 'stdio':
            current_port = None
            
        # Initialize FastMCP with the final port and protocol values
        if current_protocol == 'stdio':
            mcp = FastMCP("google_flight")
        else:
            mcp = FastMCP("google_flight", port=current_port)
        # Register all tools with the MCP instance
        register_tools(verbose=not args.json)      
            
        if args.command == "start":
            if start_server(current_port, current_protocol):
                if current_protocol == 'stdio':
                    response, exit_code = create_response(
                        True, 
                        format_message('server_started'),
                        {},
                        exit_code=0 if _server_running else 1,
                        current_port=current_port,
                        current_protocol=current_protocol
                    )
                else:
                    response, exit_code = create_response(
                        True, 
                        format_message('server_started', port=current_port),
                        {"port": current_port},
                        exit_code=0 if _server_running else 1,
                        current_port=current_port,
                        current_protocol=current_protocol
                    )
                
                if args.json:
                    print(json.dumps(response), flush=True)
        
                try:
                    while _server_running:
                        time.sleep(1)
                except KeyboardInterrupt:
                    print("\\nReceived interrupt signal")
                    stop_server(json_mode=args.json, port=current_port)
                    response, exit_code = create_response(
                        True, 
                        format_message('interrupt'),
                        current_port=current_port,
                        current_protocol=current_protocol
                    )
            else:
                response, exit_code = create_response(
                    False, 
                    format_message('server_start_fail'), 
                    exit_code=1,
                    current_port=current_port,
                    current_protocol=current_protocol
                )
                
        elif args.command == "stop":
            success = stop_server(json_mode=args.json, port=current_port)
            response, exit_code = create_response(
                success,
                format_message('stop_success' if success else 'stop_fail'),
                exit_code=0 if success else 1,
                current_port=current_port,
                current_protocol=current_protocol
            )
            
        elif args.command == "status":
            # For command line usage, check appropriate method based on protocol
            if current_protocol == 'stdio':
                # For stdio, we can't easily check if another process is running
                # so we'll just report based on what we can detect
                running = False  # Default to not running for separate process
                status_data = {"status": "running" if running else "stopped", "protocol": current_protocol}
            else:
                running = is_port_in_use(current_port)
                status_data = {"status": "running" if running else "stopped", "port": current_port, "protocol": current_protocol}
            
            msg_key = 'status_running' if running else 'status_stopped'
            response, exit_code = create_response(
                running,
                format_message(msg_key),
                status_data,
                0 if running else 1,
                current_port=current_port,
                current_protocol=current_protocol
            )
            
        elif args.command == "ping":
            # For command line usage, check appropriate method based on protocol
            if current_protocol == 'stdio':
                # For stdio, we can't easily ping another process
                running = False  # Default to not running for separate process
                ping_data = {"status": "healthy" if running else "unhealthy", "protocol": current_protocol}
            else:
                running = is_port_in_use(current_port)
                ping_data = {"status": "healthy" if running else "unhealthy", "port": current_port, "protocol": current_protocol}
            
            msg_key = 'ping_success' if running else 'ping_fail'
            response, exit_code = create_response(
                running,
                format_message(msg_key),
                ping_data,
                0 if running else 1,
                current_port=current_port,
                current_protocol=current_protocol
            )
            
        elif args.command == "version":
            import platform
            version_info = {
                "version": "1.0.0",
                "python_version": platform.python_version(),
                "platform": platform.platform(),
                "protocol": current_protocol
            }
            if current_protocol != 'stdio' and current_port is not None:
                version_info["port"] = current_port
            response, exit_code = create_response(
                True, 
                format_message('version', version=version_info['version']), 
                version_info,
                current_port=current_port,
                current_protocol=current_protocol
            )
            
        elif args.command == "help":
            parser.print_help()
            sys.exit(0)
                
    except KeyboardInterrupt:
        # Use defaults if variables are not defined
        current_port_safe = locals().get('current_port', google_flight_PORT)
        current_protocol_safe = locals().get('current_protocol', google_flight_PROTOCOL)
        response, exit_code = create_response(
            True, 
            format_message('interrupt'),
            current_port=current_port_safe,
            current_protocol=current_protocol_safe
        )
    except Exception as e:
        # Use defaults if variables are not defined
        current_port_safe = locals().get('current_port', google_flight_PORT)
        current_protocol_safe = locals().get('current_protocol', google_flight_PROTOCOL)
        response, exit_code = create_response(
            False, 
            format_message('error', error=str(e)), 
            exit_code=1,
            current_port=current_port_safe,
            current_protocol=current_protocol_safe
        )
    finally:
        if 'response' in locals():
            json_output = False
            if 'args' in locals() and hasattr(args, 'json'):
                json_output = args.json
            print_response(response, exit_code, json_output)